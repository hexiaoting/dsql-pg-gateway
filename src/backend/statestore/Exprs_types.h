/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Exprs_TYPES_H
#define Exprs_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Types_types.h"


namespace impala {

struct TExprNodeType {
  enum type {
    BOOL_LITERAL = 0,
    CASE_EXPR = 1,
    COMPOUND_PRED = 2,
    FLOAT_LITERAL = 3,
    INT_LITERAL = 4,
    IN_PRED = 5,
    IS_NULL_PRED = 6,
    LIKE_PRED = 7,
    LITERAL_PRED = 8,
    NULL_LITERAL = 9,
    SLOT_REF = 10,
    STRING_LITERAL = 11,
    TUPLE_IS_NULL_PRED = 12,
    FUNCTION_CALL = 13,
    AGGREGATE_EXPR = 14,
    DECIMAL_LITERAL = 15
  };
};

extern const std::map<int, const char*> _TExprNodeType_VALUES_TO_NAMES;

struct TExtractField {
  enum type {
    INVALID_FIELD = 0,
    YEAR = 1,
    MONTH = 2,
    DAY = 3,
    HOUR = 4,
    MINUTE = 5,
    SECOND = 6,
    MILLISECOND = 7,
    EPOCH = 8
  };
};

extern const std::map<int, const char*> _TExtractField_VALUES_TO_NAMES;


class TBoolLiteral {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  TBoolLiteral() : value(0) {
  }

  virtual ~TBoolLiteral() throw() {}

  bool value;

  void __set_value(const bool val) {
    value = val;
  }

  bool operator == (const TBoolLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TBoolLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBoolLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBoolLiteral &a, TBoolLiteral &b);


class TCaseExpr {
 public:

  static const char* ascii_fingerprint; // = "403F0C4586060E367DA428DD09C59C9C";
  static const uint8_t binary_fingerprint[16]; // = {0x40,0x3F,0x0C,0x45,0x86,0x06,0x0E,0x36,0x7D,0xA4,0x28,0xDD,0x09,0xC5,0x9C,0x9C};

  TCaseExpr() : has_case_expr(0), has_else_expr(0) {
  }

  virtual ~TCaseExpr() throw() {}

  bool has_case_expr;
  bool has_else_expr;

  void __set_has_case_expr(const bool val) {
    has_case_expr = val;
  }

  void __set_has_else_expr(const bool val) {
    has_else_expr = val;
  }

  bool operator == (const TCaseExpr & rhs) const
  {
    if (!(has_case_expr == rhs.has_case_expr))
      return false;
    if (!(has_else_expr == rhs.has_else_expr))
      return false;
    return true;
  }
  bool operator != (const TCaseExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCaseExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCaseExpr &a, TCaseExpr &b);


class TDateLiteral {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  TDateLiteral() : value(0) {
  }

  virtual ~TDateLiteral() throw() {}

   ::impala::TTimestamp value;

  void __set_value(const  ::impala::TTimestamp val) {
    value = val;
  }

  bool operator == (const TDateLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TDateLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDateLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDateLiteral &a, TDateLiteral &b);


class TDecimalLiteral {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TDecimalLiteral() : value() {
  }

  virtual ~TDecimalLiteral() throw() {}

  std::string value;

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const TDecimalLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TDecimalLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDecimalLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDecimalLiteral &a, TDecimalLiteral &b);


class TFloatLiteral {
 public:

  static const char* ascii_fingerprint; // = "66FFB53A2471384C03D9F21F6FACA58F";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xFF,0xB5,0x3A,0x24,0x71,0x38,0x4C,0x03,0xD9,0xF2,0x1F,0x6F,0xAC,0xA5,0x8F};

  TFloatLiteral() : value(0) {
  }

  virtual ~TFloatLiteral() throw() {}

  double value;

  void __set_value(const double val) {
    value = val;
  }

  bool operator == (const TFloatLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TFloatLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFloatLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFloatLiteral &a, TFloatLiteral &b);


class TIntLiteral {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  TIntLiteral() : value(0) {
  }

  virtual ~TIntLiteral() throw() {}

  int64_t value;

  void __set_value(const int64_t val) {
    value = val;
  }

  bool operator == (const TIntLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TIntLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIntLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TIntLiteral &a, TIntLiteral &b);


class TInPredicate {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  TInPredicate() : is_not_in(0) {
  }

  virtual ~TInPredicate() throw() {}

  bool is_not_in;

  void __set_is_not_in(const bool val) {
    is_not_in = val;
  }

  bool operator == (const TInPredicate & rhs) const
  {
    if (!(is_not_in == rhs.is_not_in))
      return false;
    return true;
  }
  bool operator != (const TInPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TInPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TInPredicate &a, TInPredicate &b);


class TIsNullPredicate {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  TIsNullPredicate() : is_not_null(0) {
  }

  virtual ~TIsNullPredicate() throw() {}

  bool is_not_null;

  void __set_is_not_null(const bool val) {
    is_not_null = val;
  }

  bool operator == (const TIsNullPredicate & rhs) const
  {
    if (!(is_not_null == rhs.is_not_null))
      return false;
    return true;
  }
  bool operator != (const TIsNullPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIsNullPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TIsNullPredicate &a, TIsNullPredicate &b);


class TLiteralPredicate {
 public:

  static const char* ascii_fingerprint; // = "403F0C4586060E367DA428DD09C59C9C";
  static const uint8_t binary_fingerprint[16]; // = {0x40,0x3F,0x0C,0x45,0x86,0x06,0x0E,0x36,0x7D,0xA4,0x28,0xDD,0x09,0xC5,0x9C,0x9C};

  TLiteralPredicate() : value(0), is_null(0) {
  }

  virtual ~TLiteralPredicate() throw() {}

  bool value;
  bool is_null;

  void __set_value(const bool val) {
    value = val;
  }

  void __set_is_null(const bool val) {
    is_null = val;
  }

  bool operator == (const TLiteralPredicate & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(is_null == rhs.is_null))
      return false;
    return true;
  }
  bool operator != (const TLiteralPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLiteralPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TLiteralPredicate &a, TLiteralPredicate &b);


class TTupleIsNullPredicate {
 public:

  static const char* ascii_fingerprint; // = "A803C54EAD95E24D90C5E66FB98EA72B";
  static const uint8_t binary_fingerprint[16]; // = {0xA8,0x03,0xC5,0x4E,0xAD,0x95,0xE2,0x4D,0x90,0xC5,0xE6,0x6F,0xB9,0x8E,0xA7,0x2B};

  TTupleIsNullPredicate() {
  }

  virtual ~TTupleIsNullPredicate() throw() {}

  std::vector< ::impala::TTupleId>  tuple_ids;

  void __set_tuple_ids(const std::vector< ::impala::TTupleId> & val) {
    tuple_ids = val;
  }

  bool operator == (const TTupleIsNullPredicate & rhs) const
  {
    if (!(tuple_ids == rhs.tuple_ids))
      return false;
    return true;
  }
  bool operator != (const TTupleIsNullPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTupleIsNullPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTupleIsNullPredicate &a, TTupleIsNullPredicate &b);


class TSlotRef {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  TSlotRef() : slot_id(0) {
  }

  virtual ~TSlotRef() throw() {}

   ::impala::TSlotId slot_id;

  void __set_slot_id(const  ::impala::TSlotId val) {
    slot_id = val;
  }

  bool operator == (const TSlotRef & rhs) const
  {
    if (!(slot_id == rhs.slot_id))
      return false;
    return true;
  }
  bool operator != (const TSlotRef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSlotRef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSlotRef &a, TSlotRef &b);


class TStringLiteral {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TStringLiteral() : value() {
  }

  virtual ~TStringLiteral() throw() {}

  std::string value;

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const TStringLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TStringLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStringLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStringLiteral &a, TStringLiteral &b);


class TAggregateExpr {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  TAggregateExpr() : is_merge_agg(0) {
  }

  virtual ~TAggregateExpr() throw() {}

  bool is_merge_agg;

  void __set_is_merge_agg(const bool val) {
    is_merge_agg = val;
  }

  bool operator == (const TAggregateExpr & rhs) const
  {
    if (!(is_merge_agg == rhs.is_merge_agg))
      return false;
    return true;
  }
  bool operator != (const TAggregateExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregateExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAggregateExpr &a, TAggregateExpr &b);

typedef struct _TExprNode__isset {
  _TExprNode__isset() : fn(false), vararg_start_idx(false), bool_literal(false), case_expr(false), date_literal(false), float_literal(false), int_literal(false), in_predicate(false), is_null_pred(false), literal_pred(false), slot_ref(false), string_literal(false), tuple_is_null_pred(false), decimal_literal(false), agg_expr(false) {}
  bool fn;
  bool vararg_start_idx;
  bool bool_literal;
  bool case_expr;
  bool date_literal;
  bool float_literal;
  bool int_literal;
  bool in_predicate;
  bool is_null_pred;
  bool literal_pred;
  bool slot_ref;
  bool string_literal;
  bool tuple_is_null_pred;
  bool decimal_literal;
  bool agg_expr;
} _TExprNode__isset;

class TExprNode {
 public:

  static const char* ascii_fingerprint; // = "33403D37A096279061806859579BCB89";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0x40,0x3D,0x37,0xA0,0x96,0x27,0x90,0x61,0x80,0x68,0x59,0x57,0x9B,0xCB,0x89};

  TExprNode() : node_type((TExprNodeType::type)0), num_children(0), vararg_start_idx(0) {
  }

  virtual ~TExprNode() throw() {}

  TExprNodeType::type node_type;
   ::impala::TColumnType type;
  int32_t num_children;
   ::impala::TFunction fn;
  int32_t vararg_start_idx;
  TBoolLiteral bool_literal;
  TCaseExpr case_expr;
  TDateLiteral date_literal;
  TFloatLiteral float_literal;
  TIntLiteral int_literal;
  TInPredicate in_predicate;
  TIsNullPredicate is_null_pred;
  TLiteralPredicate literal_pred;
  TSlotRef slot_ref;
  TStringLiteral string_literal;
  TTupleIsNullPredicate tuple_is_null_pred;
  TDecimalLiteral decimal_literal;
  TAggregateExpr agg_expr;

  _TExprNode__isset __isset;

  void __set_node_type(const TExprNodeType::type val) {
    node_type = val;
  }

  void __set_type(const  ::impala::TColumnType& val) {
    type = val;
  }

  void __set_num_children(const int32_t val) {
    num_children = val;
  }

  void __set_fn(const  ::impala::TFunction& val) {
    fn = val;
    __isset.fn = true;
  }

  void __set_vararg_start_idx(const int32_t val) {
    vararg_start_idx = val;
    __isset.vararg_start_idx = true;
  }

  void __set_bool_literal(const TBoolLiteral& val) {
    bool_literal = val;
    __isset.bool_literal = true;
  }

  void __set_case_expr(const TCaseExpr& val) {
    case_expr = val;
    __isset.case_expr = true;
  }

  void __set_date_literal(const TDateLiteral& val) {
    date_literal = val;
    __isset.date_literal = true;
  }

  void __set_float_literal(const TFloatLiteral& val) {
    float_literal = val;
    __isset.float_literal = true;
  }

  void __set_int_literal(const TIntLiteral& val) {
    int_literal = val;
    __isset.int_literal = true;
  }

  void __set_in_predicate(const TInPredicate& val) {
    in_predicate = val;
    __isset.in_predicate = true;
  }

  void __set_is_null_pred(const TIsNullPredicate& val) {
    is_null_pred = val;
    __isset.is_null_pred = true;
  }

  void __set_literal_pred(const TLiteralPredicate& val) {
    literal_pred = val;
    __isset.literal_pred = true;
  }

  void __set_slot_ref(const TSlotRef& val) {
    slot_ref = val;
    __isset.slot_ref = true;
  }

  void __set_string_literal(const TStringLiteral& val) {
    string_literal = val;
    __isset.string_literal = true;
  }

  void __set_tuple_is_null_pred(const TTupleIsNullPredicate& val) {
    tuple_is_null_pred = val;
    __isset.tuple_is_null_pred = true;
  }

  void __set_decimal_literal(const TDecimalLiteral& val) {
    decimal_literal = val;
    __isset.decimal_literal = true;
  }

  void __set_agg_expr(const TAggregateExpr& val) {
    agg_expr = val;
    __isset.agg_expr = true;
  }

  bool operator == (const TExprNode & rhs) const
  {
    if (!(node_type == rhs.node_type))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(num_children == rhs.num_children))
      return false;
    if (__isset.fn != rhs.__isset.fn)
      return false;
    else if (__isset.fn && !(fn == rhs.fn))
      return false;
    if (__isset.vararg_start_idx != rhs.__isset.vararg_start_idx)
      return false;
    else if (__isset.vararg_start_idx && !(vararg_start_idx == rhs.vararg_start_idx))
      return false;
    if (__isset.bool_literal != rhs.__isset.bool_literal)
      return false;
    else if (__isset.bool_literal && !(bool_literal == rhs.bool_literal))
      return false;
    if (__isset.case_expr != rhs.__isset.case_expr)
      return false;
    else if (__isset.case_expr && !(case_expr == rhs.case_expr))
      return false;
    if (__isset.date_literal != rhs.__isset.date_literal)
      return false;
    else if (__isset.date_literal && !(date_literal == rhs.date_literal))
      return false;
    if (__isset.float_literal != rhs.__isset.float_literal)
      return false;
    else if (__isset.float_literal && !(float_literal == rhs.float_literal))
      return false;
    if (__isset.int_literal != rhs.__isset.int_literal)
      return false;
    else if (__isset.int_literal && !(int_literal == rhs.int_literal))
      return false;
    if (__isset.in_predicate != rhs.__isset.in_predicate)
      return false;
    else if (__isset.in_predicate && !(in_predicate == rhs.in_predicate))
      return false;
    if (__isset.is_null_pred != rhs.__isset.is_null_pred)
      return false;
    else if (__isset.is_null_pred && !(is_null_pred == rhs.is_null_pred))
      return false;
    if (__isset.literal_pred != rhs.__isset.literal_pred)
      return false;
    else if (__isset.literal_pred && !(literal_pred == rhs.literal_pred))
      return false;
    if (__isset.slot_ref != rhs.__isset.slot_ref)
      return false;
    else if (__isset.slot_ref && !(slot_ref == rhs.slot_ref))
      return false;
    if (__isset.string_literal != rhs.__isset.string_literal)
      return false;
    else if (__isset.string_literal && !(string_literal == rhs.string_literal))
      return false;
    if (__isset.tuple_is_null_pred != rhs.__isset.tuple_is_null_pred)
      return false;
    else if (__isset.tuple_is_null_pred && !(tuple_is_null_pred == rhs.tuple_is_null_pred))
      return false;
    if (__isset.decimal_literal != rhs.__isset.decimal_literal)
      return false;
    else if (__isset.decimal_literal && !(decimal_literal == rhs.decimal_literal))
      return false;
    if (__isset.agg_expr != rhs.__isset.agg_expr)
      return false;
    else if (__isset.agg_expr && !(agg_expr == rhs.agg_expr))
      return false;
    return true;
  }
  bool operator != (const TExprNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExprNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExprNode &a, TExprNode &b);


class TExpr {
 public:

  static const char* ascii_fingerprint; // = "01EFF48BB9FFD609F9A86B77FA7F9846";
  static const uint8_t binary_fingerprint[16]; // = {0x01,0xEF,0xF4,0x8B,0xB9,0xFF,0xD6,0x09,0xF9,0xA8,0x6B,0x77,0xFA,0x7F,0x98,0x46};

  TExpr() {
  }

  virtual ~TExpr() throw() {}

  std::vector<TExprNode>  nodes;

  void __set_nodes(const std::vector<TExprNode> & val) {
    nodes = val;
  }

  bool operator == (const TExpr & rhs) const
  {
    if (!(nodes == rhs.nodes))
      return false;
    return true;
  }
  bool operator != (const TExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExpr &a, TExpr &b);


class TExprBatch {
 public:

  static const char* ascii_fingerprint; // = "E968773DC466D549504A7C681FF8B82E";
  static const uint8_t binary_fingerprint[16]; // = {0xE9,0x68,0x77,0x3D,0xC4,0x66,0xD5,0x49,0x50,0x4A,0x7C,0x68,0x1F,0xF8,0xB8,0x2E};

  TExprBatch() {
  }

  virtual ~TExprBatch() throw() {}

  std::vector<TExpr>  exprs;

  void __set_exprs(const std::vector<TExpr> & val) {
    exprs = val;
  }

  bool operator == (const TExprBatch & rhs) const
  {
    if (!(exprs == rhs.exprs))
      return false;
    return true;
  }
  bool operator != (const TExprBatch &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExprBatch & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExprBatch &a, TExprBatch &b);

} // namespace

#endif
