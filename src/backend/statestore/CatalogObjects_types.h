/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef CatalogObjects_TYPES_H
#define CatalogObjects_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Exprs_types.h"
#include "Status_types.h"
#include "Types_types.h"
#include "../gen-cpp/hive_metastore_types.h"


namespace impala {

struct TCatalogObjectType {
  enum type {
    UNKNOWN = 0,
    CATALOG = 1,
    DATABASE = 2,
    TABLE = 3,
    VIEW = 4,
    FUNCTION = 5,
    DATA_SOURCE = 6,
    ROLE = 7,
    PRIVILEGE = 8,
    HDFS_CACHE_POOL = 9,
    INDEX = 10,
    LIBRARY = 11
  };
};

extern const std::map<int, const char*> _TCatalogObjectType_VALUES_TO_NAMES;

struct TTableType {
  enum type {
    HDFS_TABLE = 0,
    HBASE_TABLE = 1,
    VIEW = 2,
    DATA_SOURCE_TABLE = 3,
    PG_TABLE = 4,
    STREAM_TABLE = 5,
    PHOENIX_TABLE = 6
  };
};

extern const std::map<int, const char*> _TTableType_VALUES_TO_NAMES;

struct THdfsFileFormat {
  enum type {
    TEXT = 0,
    RC_FILE = 1,
    SEQUENCE_FILE = 2,
    AVRO = 3,
    PARQUET = 4,
    NONE = 5
  };
};

extern const std::map<int, const char*> _THdfsFileFormat_VALUES_TO_NAMES;

struct THdfsCompression {
  enum type {
    NONE = 0,
    DEFAULT = 1,
    GZIP = 2,
    DEFLATE = 3,
    BZIP2 = 4,
    SNAPPY = 5,
    SNAPPY_BLOCKED = 6,
    LZO = 7,
    LZ4 = 8
  };
};

extern const std::map<int, const char*> _THdfsCompression_VALUES_TO_NAMES;

struct THdfsSeqCompressionMode {
  enum type {
    RECORD = 0,
    BLOCK = 1
  };
};

extern const std::map<int, const char*> _THdfsSeqCompressionMode_VALUES_TO_NAMES;

struct TTablePropertyType {
  enum type {
    TBL_PROPERTY = 0,
    SERDE_PROPERTY = 1
  };
};

extern const std::map<int, const char*> _TTablePropertyType_VALUES_TO_NAMES;

struct TAccessLevel {
  enum type {
    NONE = 0,
    READ_WRITE = 1,
    READ_ONLY = 2,
    WRITE_ONLY = 3
  };
};

extern const std::map<int, const char*> _TAccessLevel_VALUES_TO_NAMES;

struct TUriType {
  enum type {
    HIVE = 0,
    PG = 1,
    STREAM = 2,
    PHOENIX = 3
  };
};

extern const std::map<int, const char*> _TUriType_VALUES_TO_NAMES;

struct TPrivilegeScope {
  enum type {
    SERVER = 0,
    URI = 1,
    DATABASE = 2,
    TABLE = 3,
    COLUMN = 4
  };
};

extern const std::map<int, const char*> _TPrivilegeScope_VALUES_TO_NAMES;

struct TPrivilegeLevel {
  enum type {
    ALL = 0,
    INSERT = 1,
    SELECT = 2
  };
};

extern const std::map<int, const char*> _TPrivilegeLevel_VALUES_TO_NAMES;


class TPartitionKeyValue {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  TPartitionKeyValue() : name(), value() {
  }

  virtual ~TPartitionKeyValue() throw() {}

  std::string name;
  std::string value;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const TPartitionKeyValue & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TPartitionKeyValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPartitionKeyValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPartitionKeyValue &a, TPartitionKeyValue &b);


class TTableName {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  TTableName() : db_name(), table_name() {
  }

  virtual ~TTableName() throw() {}

  std::string db_name;
  std::string table_name;

  void __set_db_name(const std::string& val) {
    db_name = val;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  bool operator == (const TTableName & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const TTableName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableName &a, TTableName &b);


class TTableStats {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  TTableStats() : num_rows(0) {
  }

  virtual ~TTableStats() throw() {}

  int64_t num_rows;

  void __set_num_rows(const int64_t val) {
    num_rows = val;
  }

  bool operator == (const TTableStats & rhs) const
  {
    if (!(num_rows == rhs.num_rows))
      return false;
    return true;
  }
  bool operator != (const TTableStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableStats &a, TTableStats &b);


class TColumnStats {
 public:

  static const char* ascii_fingerprint; // = "D5FF58B203C57D2B1EF98050D612DB56";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0xFF,0x58,0xB2,0x03,0xC5,0x7D,0x2B,0x1E,0xF9,0x80,0x50,0xD6,0x12,0xDB,0x56};

  TColumnStats() : avg_size(0), max_size(0), num_distinct_values(0), num_nulls(0) {
  }

  virtual ~TColumnStats() throw() {}

  double avg_size;
  int64_t max_size;
  int64_t num_distinct_values;
  int64_t num_nulls;

  void __set_avg_size(const double val) {
    avg_size = val;
  }

  void __set_max_size(const int64_t val) {
    max_size = val;
  }

  void __set_num_distinct_values(const int64_t val) {
    num_distinct_values = val;
  }

  void __set_num_nulls(const int64_t val) {
    num_nulls = val;
  }

  bool operator == (const TColumnStats & rhs) const
  {
    if (!(avg_size == rhs.avg_size))
      return false;
    if (!(max_size == rhs.max_size))
      return false;
    if (!(num_distinct_values == rhs.num_distinct_values))
      return false;
    if (!(num_nulls == rhs.num_nulls))
      return false;
    return true;
  }
  bool operator != (const TColumnStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumnStats &a, TColumnStats &b);

typedef struct _TIntermediateColumnStats__isset {
  _TIntermediateColumnStats__isset() : intermediate_ndv(false), is_ndv_encoded(false), num_nulls(false), max_width(false), avg_width(false), num_rows(false) {}
  bool intermediate_ndv;
  bool is_ndv_encoded;
  bool num_nulls;
  bool max_width;
  bool avg_width;
  bool num_rows;
} _TIntermediateColumnStats__isset;

class TIntermediateColumnStats {
 public:

  static const char* ascii_fingerprint; // = "F89B7426F451543B11701B02D64A9AF2";
  static const uint8_t binary_fingerprint[16]; // = {0xF8,0x9B,0x74,0x26,0xF4,0x51,0x54,0x3B,0x11,0x70,0x1B,0x02,0xD6,0x4A,0x9A,0xF2};

  TIntermediateColumnStats() : intermediate_ndv(), is_ndv_encoded(0), num_nulls(0), max_width(0), avg_width(0), num_rows(0) {
  }

  virtual ~TIntermediateColumnStats() throw() {}

  std::string intermediate_ndv;
  bool is_ndv_encoded;
  int64_t num_nulls;
  int32_t max_width;
  double avg_width;
  int64_t num_rows;

  _TIntermediateColumnStats__isset __isset;

  void __set_intermediate_ndv(const std::string& val) {
    intermediate_ndv = val;
    __isset.intermediate_ndv = true;
  }

  void __set_is_ndv_encoded(const bool val) {
    is_ndv_encoded = val;
    __isset.is_ndv_encoded = true;
  }

  void __set_num_nulls(const int64_t val) {
    num_nulls = val;
    __isset.num_nulls = true;
  }

  void __set_max_width(const int32_t val) {
    max_width = val;
    __isset.max_width = true;
  }

  void __set_avg_width(const double val) {
    avg_width = val;
    __isset.avg_width = true;
  }

  void __set_num_rows(const int64_t val) {
    num_rows = val;
    __isset.num_rows = true;
  }

  bool operator == (const TIntermediateColumnStats & rhs) const
  {
    if (__isset.intermediate_ndv != rhs.__isset.intermediate_ndv)
      return false;
    else if (__isset.intermediate_ndv && !(intermediate_ndv == rhs.intermediate_ndv))
      return false;
    if (__isset.is_ndv_encoded != rhs.__isset.is_ndv_encoded)
      return false;
    else if (__isset.is_ndv_encoded && !(is_ndv_encoded == rhs.is_ndv_encoded))
      return false;
    if (__isset.num_nulls != rhs.__isset.num_nulls)
      return false;
    else if (__isset.num_nulls && !(num_nulls == rhs.num_nulls))
      return false;
    if (__isset.max_width != rhs.__isset.max_width)
      return false;
    else if (__isset.max_width && !(max_width == rhs.max_width))
      return false;
    if (__isset.avg_width != rhs.__isset.avg_width)
      return false;
    else if (__isset.avg_width && !(avg_width == rhs.avg_width))
      return false;
    if (__isset.num_rows != rhs.__isset.num_rows)
      return false;
    else if (__isset.num_rows && !(num_rows == rhs.num_rows))
      return false;
    return true;
  }
  bool operator != (const TIntermediateColumnStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIntermediateColumnStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TIntermediateColumnStats &a, TIntermediateColumnStats &b);

typedef struct _TPartitionStats__isset {
  _TPartitionStats__isset() : intermediate_col_stats(false) {}
  bool intermediate_col_stats;
} _TPartitionStats__isset;

class TPartitionStats {
 public:

  static const char* ascii_fingerprint; // = "98BD569BF2AD25B1B80BFCECFCFE3E8D";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0xBD,0x56,0x9B,0xF2,0xAD,0x25,0xB1,0xB8,0x0B,0xFC,0xEC,0xFC,0xFE,0x3E,0x8D};

  TPartitionStats() {
  }

  virtual ~TPartitionStats() throw() {}

  TTableStats stats;
  std::map<std::string, TIntermediateColumnStats>  intermediate_col_stats;

  _TPartitionStats__isset __isset;

  void __set_stats(const TTableStats& val) {
    stats = val;
  }

  void __set_intermediate_col_stats(const std::map<std::string, TIntermediateColumnStats> & val) {
    intermediate_col_stats = val;
    __isset.intermediate_col_stats = true;
  }

  bool operator == (const TPartitionStats & rhs) const
  {
    if (!(stats == rhs.stats))
      return false;
    if (__isset.intermediate_col_stats != rhs.__isset.intermediate_col_stats)
      return false;
    else if (__isset.intermediate_col_stats && !(intermediate_col_stats == rhs.intermediate_col_stats))
      return false;
    return true;
  }
  bool operator != (const TPartitionStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPartitionStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPartitionStats &a, TPartitionStats &b);

typedef struct _TColumn__isset {
  _TColumn__isset() : comment(false), col_stats(false), position(false), is_hbase_column(false), column_family(false), column_qualifier(false), is_binary(false) {}
  bool comment;
  bool col_stats;
  bool position;
  bool is_hbase_column;
  bool column_family;
  bool column_qualifier;
  bool is_binary;
} _TColumn__isset;

class TColumn {
 public:

  static const char* ascii_fingerprint; // = "6FDCB72B96621B6C2A51DC13B6AA172A";
  static const uint8_t binary_fingerprint[16]; // = {0x6F,0xDC,0xB7,0x2B,0x96,0x62,0x1B,0x6C,0x2A,0x51,0xDC,0x13,0xB6,0xAA,0x17,0x2A};

  TColumn() : columnName(), comment(), position(0), is_hbase_column(0), column_family(), column_qualifier(), is_binary(0) {
  }

  virtual ~TColumn() throw() {}

  std::string columnName;
   ::impala::TColumnType columnType;
  std::string comment;
  TColumnStats col_stats;
  int32_t position;
  bool is_hbase_column;
  std::string column_family;
  std::string column_qualifier;
  bool is_binary;

  _TColumn__isset __isset;

  void __set_columnName(const std::string& val) {
    columnName = val;
  }

  void __set_columnType(const  ::impala::TColumnType& val) {
    columnType = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_col_stats(const TColumnStats& val) {
    col_stats = val;
    __isset.col_stats = true;
  }

  void __set_position(const int32_t val) {
    position = val;
    __isset.position = true;
  }

  void __set_is_hbase_column(const bool val) {
    is_hbase_column = val;
    __isset.is_hbase_column = true;
  }

  void __set_column_family(const std::string& val) {
    column_family = val;
    __isset.column_family = true;
  }

  void __set_column_qualifier(const std::string& val) {
    column_qualifier = val;
    __isset.column_qualifier = true;
  }

  void __set_is_binary(const bool val) {
    is_binary = val;
    __isset.is_binary = true;
  }

  bool operator == (const TColumn & rhs) const
  {
    if (!(columnName == rhs.columnName))
      return false;
    if (!(columnType == rhs.columnType))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.col_stats != rhs.__isset.col_stats)
      return false;
    else if (__isset.col_stats && !(col_stats == rhs.col_stats))
      return false;
    if (__isset.position != rhs.__isset.position)
      return false;
    else if (__isset.position && !(position == rhs.position))
      return false;
    if (__isset.is_hbase_column != rhs.__isset.is_hbase_column)
      return false;
    else if (__isset.is_hbase_column && !(is_hbase_column == rhs.is_hbase_column))
      return false;
    if (__isset.column_family != rhs.__isset.column_family)
      return false;
    else if (__isset.column_family && !(column_family == rhs.column_family))
      return false;
    if (__isset.column_qualifier != rhs.__isset.column_qualifier)
      return false;
    else if (__isset.column_qualifier && !(column_qualifier == rhs.column_qualifier))
      return false;
    if (__isset.is_binary != rhs.__isset.is_binary)
      return false;
    else if (__isset.is_binary && !(is_binary == rhs.is_binary))
      return false;
    return true;
  }
  bool operator != (const TColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumn &a, TColumn &b);

typedef struct _THdfsFileBlock__isset {
  _THdfsFileBlock__isset() : disk_ids(false), is_replica_cached(false) {}
  bool disk_ids;
  bool is_replica_cached;
} _THdfsFileBlock__isset;

class THdfsFileBlock {
 public:

  static const char* ascii_fingerprint; // = "11720BFD3AD04B8A78FD5DCBA5CCDEFF";
  static const uint8_t binary_fingerprint[16]; // = {0x11,0x72,0x0B,0xFD,0x3A,0xD0,0x4B,0x8A,0x78,0xFD,0x5D,0xCB,0xA5,0xCC,0xDE,0xFF};

  THdfsFileBlock() : offset(0), length(0) {
  }

  virtual ~THdfsFileBlock() throw() {}

  int64_t offset;
  int64_t length;
  std::vector<int32_t>  replica_host_idxs;
  std::vector<int32_t>  disk_ids;
  std::vector<bool>  is_replica_cached;

  _THdfsFileBlock__isset __isset;

  void __set_offset(const int64_t val) {
    offset = val;
  }

  void __set_length(const int64_t val) {
    length = val;
  }

  void __set_replica_host_idxs(const std::vector<int32_t> & val) {
    replica_host_idxs = val;
  }

  void __set_disk_ids(const std::vector<int32_t> & val) {
    disk_ids = val;
    __isset.disk_ids = true;
  }

  void __set_is_replica_cached(const std::vector<bool> & val) {
    is_replica_cached = val;
    __isset.is_replica_cached = true;
  }

  bool operator == (const THdfsFileBlock & rhs) const
  {
    if (!(offset == rhs.offset))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(replica_host_idxs == rhs.replica_host_idxs))
      return false;
    if (__isset.disk_ids != rhs.__isset.disk_ids)
      return false;
    else if (__isset.disk_ids && !(disk_ids == rhs.disk_ids))
      return false;
    if (__isset.is_replica_cached != rhs.__isset.is_replica_cached)
      return false;
    else if (__isset.is_replica_cached && !(is_replica_cached == rhs.is_replica_cached))
      return false;
    return true;
  }
  bool operator != (const THdfsFileBlock &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsFileBlock & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsFileBlock &a, THdfsFileBlock &b);


class THdfsFileDesc {
 public:

  static const char* ascii_fingerprint; // = "425A3488D3AEC10B76A7420BF5474B94";
  static const uint8_t binary_fingerprint[16]; // = {0x42,0x5A,0x34,0x88,0xD3,0xAE,0xC1,0x0B,0x76,0xA7,0x42,0x0B,0xF5,0x47,0x4B,0x94};

  THdfsFileDesc() : file_name(), length(0), compression((THdfsCompression::type)0), last_modification_time(0) {
  }

  virtual ~THdfsFileDesc() throw() {}

  std::string file_name;
  int64_t length;
  THdfsCompression::type compression;
  int64_t last_modification_time;
  std::vector<THdfsFileBlock>  file_blocks;

  void __set_file_name(const std::string& val) {
    file_name = val;
  }

  void __set_length(const int64_t val) {
    length = val;
  }

  void __set_compression(const THdfsCompression::type val) {
    compression = val;
  }

  void __set_last_modification_time(const int64_t val) {
    last_modification_time = val;
  }

  void __set_file_blocks(const std::vector<THdfsFileBlock> & val) {
    file_blocks = val;
  }

  bool operator == (const THdfsFileDesc & rhs) const
  {
    if (!(file_name == rhs.file_name))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(compression == rhs.compression))
      return false;
    if (!(last_modification_time == rhs.last_modification_time))
      return false;
    if (!(file_blocks == rhs.file_blocks))
      return false;
    return true;
  }
  bool operator != (const THdfsFileDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsFileDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsFileDesc &a, THdfsFileDesc &b);

typedef struct _THdfsPartition__isset {
  _THdfsPartition__isset() : partitionKeyExprs(false), file_desc(false), location(false), access_level(false), stats(false), is_marked_cached(false), id(false), hms_parameters(false) {}
  bool partitionKeyExprs;
  bool file_desc;
  bool location;
  bool access_level;
  bool stats;
  bool is_marked_cached;
  bool id;
  bool hms_parameters;
} _THdfsPartition__isset;

class THdfsPartition {
 public:

  static const char* ascii_fingerprint; // = "09B6E2E7D9D39CCA06A0557A02D5111D";
  static const uint8_t binary_fingerprint[16]; // = {0x09,0xB6,0xE2,0xE7,0xD9,0xD3,0x9C,0xCA,0x06,0xA0,0x55,0x7A,0x02,0xD5,0x11,0x1D};

  THdfsPartition() : lineDelim(0), fieldDelim(0), collectionDelim(0), mapKeyDelim(0), escapeChar(0), fileFormat((THdfsFileFormat::type)0), blockSize(0), location(), access_level((TAccessLevel::type)0), is_marked_cached(0), id(0) {
  }

  virtual ~THdfsPartition() throw() {}

  int8_t lineDelim;
  int8_t fieldDelim;
  int8_t collectionDelim;
  int8_t mapKeyDelim;
  int8_t escapeChar;
  THdfsFileFormat::type fileFormat;
  std::vector< ::impala::TExpr>  partitionKeyExprs;
  int32_t blockSize;
  std::vector<THdfsFileDesc>  file_desc;
  std::string location;
  TAccessLevel::type access_level;
  TTableStats stats;
  bool is_marked_cached;
  int64_t id;
  std::map<std::string, std::string>  hms_parameters;

  _THdfsPartition__isset __isset;

  void __set_lineDelim(const int8_t val) {
    lineDelim = val;
  }

  void __set_fieldDelim(const int8_t val) {
    fieldDelim = val;
  }

  void __set_collectionDelim(const int8_t val) {
    collectionDelim = val;
  }

  void __set_mapKeyDelim(const int8_t val) {
    mapKeyDelim = val;
  }

  void __set_escapeChar(const int8_t val) {
    escapeChar = val;
  }

  void __set_fileFormat(const THdfsFileFormat::type val) {
    fileFormat = val;
  }

  void __set_partitionKeyExprs(const std::vector< ::impala::TExpr> & val) {
    partitionKeyExprs = val;
    __isset.partitionKeyExprs = true;
  }

  void __set_blockSize(const int32_t val) {
    blockSize = val;
  }

  void __set_file_desc(const std::vector<THdfsFileDesc> & val) {
    file_desc = val;
    __isset.file_desc = true;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  void __set_access_level(const TAccessLevel::type val) {
    access_level = val;
    __isset.access_level = true;
  }

  void __set_stats(const TTableStats& val) {
    stats = val;
    __isset.stats = true;
  }

  void __set_is_marked_cached(const bool val) {
    is_marked_cached = val;
    __isset.is_marked_cached = true;
  }

  void __set_id(const int64_t val) {
    id = val;
    __isset.id = true;
  }

  void __set_hms_parameters(const std::map<std::string, std::string> & val) {
    hms_parameters = val;
    __isset.hms_parameters = true;
  }

  bool operator == (const THdfsPartition & rhs) const
  {
    if (!(lineDelim == rhs.lineDelim))
      return false;
    if (!(fieldDelim == rhs.fieldDelim))
      return false;
    if (!(collectionDelim == rhs.collectionDelim))
      return false;
    if (!(mapKeyDelim == rhs.mapKeyDelim))
      return false;
    if (!(escapeChar == rhs.escapeChar))
      return false;
    if (!(fileFormat == rhs.fileFormat))
      return false;
    if (!(partitionKeyExprs == rhs.partitionKeyExprs))
      return false;
    if (!(blockSize == rhs.blockSize))
      return false;
    if (__isset.file_desc != rhs.__isset.file_desc)
      return false;
    else if (__isset.file_desc && !(file_desc == rhs.file_desc))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    if (__isset.access_level != rhs.__isset.access_level)
      return false;
    else if (__isset.access_level && !(access_level == rhs.access_level))
      return false;
    if (__isset.stats != rhs.__isset.stats)
      return false;
    else if (__isset.stats && !(stats == rhs.stats))
      return false;
    if (__isset.is_marked_cached != rhs.__isset.is_marked_cached)
      return false;
    else if (__isset.is_marked_cached && !(is_marked_cached == rhs.is_marked_cached))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.hms_parameters != rhs.__isset.hms_parameters)
      return false;
    else if (__isset.hms_parameters && !(hms_parameters == rhs.hms_parameters))
      return false;
    return true;
  }
  bool operator != (const THdfsPartition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsPartition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsPartition &a, THdfsPartition &b);

typedef struct _THdfsTable__isset {
  _THdfsTable__isset() : avroSchema(false), network_addresses(false), multiple_filesystems(false) {}
  bool avroSchema;
  bool network_addresses;
  bool multiple_filesystems;
} _THdfsTable__isset;

class THdfsTable {
 public:

  static const char* ascii_fingerprint; // = "21B5F8E37E85CF1B063E6E97DD6FE936";
  static const uint8_t binary_fingerprint[16]; // = {0x21,0xB5,0xF8,0xE3,0x7E,0x85,0xCF,0x1B,0x06,0x3E,0x6E,0x97,0xDD,0x6F,0xE9,0x36};

  THdfsTable() : hdfsBaseDir(), nullPartitionKeyValue(), nullColumnValue(), avroSchema(), multiple_filesystems(0) {
  }

  virtual ~THdfsTable() throw() {}

  std::string hdfsBaseDir;
  std::vector<std::string>  colNames;
  std::string nullPartitionKeyValue;
  std::string nullColumnValue;
  std::string avroSchema;
  std::map<int64_t, THdfsPartition>  partitions;
  std::vector< ::impala::TNetworkAddress>  network_addresses;
  bool multiple_filesystems;

  _THdfsTable__isset __isset;

  void __set_hdfsBaseDir(const std::string& val) {
    hdfsBaseDir = val;
  }

  void __set_colNames(const std::vector<std::string> & val) {
    colNames = val;
  }

  void __set_nullPartitionKeyValue(const std::string& val) {
    nullPartitionKeyValue = val;
  }

  void __set_nullColumnValue(const std::string& val) {
    nullColumnValue = val;
  }

  void __set_avroSchema(const std::string& val) {
    avroSchema = val;
    __isset.avroSchema = true;
  }

  void __set_partitions(const std::map<int64_t, THdfsPartition> & val) {
    partitions = val;
  }

  void __set_network_addresses(const std::vector< ::impala::TNetworkAddress> & val) {
    network_addresses = val;
    __isset.network_addresses = true;
  }

  void __set_multiple_filesystems(const bool val) {
    multiple_filesystems = val;
    __isset.multiple_filesystems = true;
  }

  bool operator == (const THdfsTable & rhs) const
  {
    if (!(hdfsBaseDir == rhs.hdfsBaseDir))
      return false;
    if (!(colNames == rhs.colNames))
      return false;
    if (!(nullPartitionKeyValue == rhs.nullPartitionKeyValue))
      return false;
    if (!(nullColumnValue == rhs.nullColumnValue))
      return false;
    if (__isset.avroSchema != rhs.__isset.avroSchema)
      return false;
    else if (__isset.avroSchema && !(avroSchema == rhs.avroSchema))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    if (__isset.network_addresses != rhs.__isset.network_addresses)
      return false;
    else if (__isset.network_addresses && !(network_addresses == rhs.network_addresses))
      return false;
    if (__isset.multiple_filesystems != rhs.__isset.multiple_filesystems)
      return false;
    else if (__isset.multiple_filesystems && !(multiple_filesystems == rhs.multiple_filesystems))
      return false;
    return true;
  }
  bool operator != (const THdfsTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsTable &a, THdfsTable &b);

typedef struct _THBaseTable__isset {
  _THBaseTable__isset() : binary_encoded(false) {}
  bool binary_encoded;
} _THBaseTable__isset;

class THBaseTable {
 public:

  static const char* ascii_fingerprint; // = "1020D6DBCD4B2FB077A077715FEA851B";
  static const uint8_t binary_fingerprint[16]; // = {0x10,0x20,0xD6,0xDB,0xCD,0x4B,0x2F,0xB0,0x77,0xA0,0x77,0x71,0x5F,0xEA,0x85,0x1B};

  THBaseTable() : tableName() {
  }

  virtual ~THBaseTable() throw() {}

  std::string tableName;
  std::vector<std::string>  families;
  std::vector<std::string>  qualifiers;
  std::vector<bool>  binary_encoded;

  _THBaseTable__isset __isset;

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_families(const std::vector<std::string> & val) {
    families = val;
  }

  void __set_qualifiers(const std::vector<std::string> & val) {
    qualifiers = val;
  }

  void __set_binary_encoded(const std::vector<bool> & val) {
    binary_encoded = val;
    __isset.binary_encoded = true;
  }

  bool operator == (const THBaseTable & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(families == rhs.families))
      return false;
    if (!(qualifiers == rhs.qualifiers))
      return false;
    if (__isset.binary_encoded != rhs.__isset.binary_encoded)
      return false;
    else if (__isset.binary_encoded && !(binary_encoded == rhs.binary_encoded))
      return false;
    return true;
  }
  bool operator != (const THBaseTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THBaseTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THBaseTable &a, THBaseTable &b);


class TDataSource {
 public:

  static const char* ascii_fingerprint; // = "C93D890311F28844166CF6E571EB3AC2";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};

  TDataSource() : name(), hdfs_location(), class_name(), api_version() {
  }

  virtual ~TDataSource() throw() {}

  std::string name;
  std::string hdfs_location;
  std::string class_name;
  std::string api_version;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_hdfs_location(const std::string& val) {
    hdfs_location = val;
  }

  void __set_class_name(const std::string& val) {
    class_name = val;
  }

  void __set_api_version(const std::string& val) {
    api_version = val;
  }

  bool operator == (const TDataSource & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(hdfs_location == rhs.hdfs_location))
      return false;
    if (!(class_name == rhs.class_name))
      return false;
    if (!(api_version == rhs.api_version))
      return false;
    return true;
  }
  bool operator != (const TDataSource &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataSource & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDataSource &a, TDataSource &b);


class TDataSourceTable {
 public:

  static const char* ascii_fingerprint; // = "7ADC8F063F12245EDF20DEB68DBB1D55";
  static const uint8_t binary_fingerprint[16]; // = {0x7A,0xDC,0x8F,0x06,0x3F,0x12,0x24,0x5E,0xDF,0x20,0xDE,0xB6,0x8D,0xBB,0x1D,0x55};

  TDataSourceTable() : init_string() {
  }

  virtual ~TDataSourceTable() throw() {}

  TDataSource data_source;
  std::string init_string;

  void __set_data_source(const TDataSource& val) {
    data_source = val;
  }

  void __set_init_string(const std::string& val) {
    init_string = val;
  }

  bool operator == (const TDataSourceTable & rhs) const
  {
    if (!(data_source == rhs.data_source))
      return false;
    if (!(init_string == rhs.init_string))
      return false;
    return true;
  }
  bool operator != (const TDataSourceTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataSourceTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDataSourceTable &a, TDataSourceTable &b);


class TPGTablet {
 public:

  static const char* ascii_fingerprint; // = "B87B6F57864ED98AD1BA3E1CD6F87805";
  static const uint8_t binary_fingerprint[16]; // = {0xB8,0x7B,0x6F,0x57,0x86,0x4E,0xD9,0x8A,0xD1,0xBA,0x3E,0x1C,0xD6,0xF8,0x78,0x05};

  TPGTablet() : table_name() {
  }

  virtual ~TPGTablet() throw() {}

  std::string table_name;
  std::vector< ::impala::TNetworkAddress>  addrs;

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  void __set_addrs(const std::vector< ::impala::TNetworkAddress> & val) {
    addrs = val;
  }

  bool operator == (const TPGTablet & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(addrs == rhs.addrs))
      return false;
    return true;
  }
  bool operator != (const TPGTablet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPGTablet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPGTablet &a, TPGTablet &b);

typedef struct _TPGPartition__isset {
  _TPGPartition__isset() : tablets(false), stats(false), id(false), parameters(false) {}
  bool tablets;
  bool stats;
  bool id;
  bool parameters;
} _TPGPartition__isset;

class TPGPartition {
 public:

  static const char* ascii_fingerprint; // = "E6693F194F8AF4C7A4CCF6A470F3C29E";
  static const uint8_t binary_fingerprint[16]; // = {0xE6,0x69,0x3F,0x19,0x4F,0x8A,0xF4,0xC7,0xA4,0xCC,0xF6,0xA4,0x70,0xF3,0xC2,0x9E};

  TPGPartition() : id(0) {
  }

  virtual ~TPGPartition() throw() {}

  std::vector< ::impala::TExpr>  partitionKeyExprs;
  std::vector<TPGTablet>  tablets;
  TTableStats stats;
  int64_t id;
  std::map<std::string, std::string>  parameters;

  _TPGPartition__isset __isset;

  void __set_partitionKeyExprs(const std::vector< ::impala::TExpr> & val) {
    partitionKeyExprs = val;
  }

  void __set_tablets(const std::vector<TPGTablet> & val) {
    tablets = val;
    __isset.tablets = true;
  }

  void __set_stats(const TTableStats& val) {
    stats = val;
    __isset.stats = true;
  }

  void __set_id(const int64_t val) {
    id = val;
    __isset.id = true;
  }

  void __set_parameters(const std::map<std::string, std::string> & val) {
    parameters = val;
    __isset.parameters = true;
  }

  bool operator == (const TPGPartition & rhs) const
  {
    if (!(partitionKeyExprs == rhs.partitionKeyExprs))
      return false;
    if (__isset.tablets != rhs.__isset.tablets)
      return false;
    else if (__isset.tablets && !(tablets == rhs.tablets))
      return false;
    if (__isset.stats != rhs.__isset.stats)
      return false;
    else if (__isset.stats && !(stats == rhs.stats))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.parameters != rhs.__isset.parameters)
      return false;
    else if (__isset.parameters && !(parameters == rhs.parameters))
      return false;
    return true;
  }
  bool operator != (const TPGPartition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPGPartition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPGPartition &a, TPGPartition &b);


class TPGTable {
 public:

  static const char* ascii_fingerprint; // = "E62633871D0FAFFE579ED97505D34EB1";
  static const uint8_t binary_fingerprint[16]; // = {0xE6,0x26,0x33,0x87,0x1D,0x0F,0xAF,0xFE,0x57,0x9E,0xD9,0x75,0x05,0xD3,0x4E,0xB1};

  TPGTable() : tableName(), owner(), sql() {
  }

  virtual ~TPGTable() throw() {}

  std::string tableName;
  std::string owner;
  std::map<int64_t, TPGPartition>  partitions;
  std::vector<TColumn>  partition_columns;
  std::string sql;

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_owner(const std::string& val) {
    owner = val;
  }

  void __set_partitions(const std::map<int64_t, TPGPartition> & val) {
    partitions = val;
  }

  void __set_partition_columns(const std::vector<TColumn> & val) {
    partition_columns = val;
  }

  void __set_sql(const std::string& val) {
    sql = val;
  }

  bool operator == (const TPGTable & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    if (!(partition_columns == rhs.partition_columns))
      return false;
    if (!(sql == rhs.sql))
      return false;
    return true;
  }
  bool operator != (const TPGTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPGTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPGTable &a, TPGTable &b);

typedef struct _TDsqlUri__isset {
  _TDsqlUri__isset() : pg_locations(false), port(false), url(false), db_name(false), offset(false), num_nodes(false) {}
  bool pg_locations;
  bool port;
  bool url;
  bool db_name;
  bool offset;
  bool num_nodes;
} _TDsqlUri__isset;

class TDsqlUri {
 public:

  static const char* ascii_fingerprint; // = "078407A192271140B6E96CEE7F2BF932";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0x84,0x07,0xA1,0x92,0x27,0x11,0x40,0xB6,0xE9,0x6C,0xEE,0x7F,0x2B,0xF9,0x32};

  TDsqlUri() : type((TUriType::type)0), port(0), url(), db_name(), offset(0), num_nodes(0) {
  }

  virtual ~TDsqlUri() throw() {}

  TUriType::type type;
  std::vector<std::string>  pg_locations;
  int32_t port;
  std::string url;
  std::string db_name;
  int32_t offset;
  int32_t num_nodes;

  _TDsqlUri__isset __isset;

  void __set_type(const TUriType::type val) {
    type = val;
  }

  void __set_pg_locations(const std::vector<std::string> & val) {
    pg_locations = val;
    __isset.pg_locations = true;
  }

  void __set_port(const int32_t val) {
    port = val;
    __isset.port = true;
  }

  void __set_url(const std::string& val) {
    url = val;
    __isset.url = true;
  }

  void __set_db_name(const std::string& val) {
    db_name = val;
    __isset.db_name = true;
  }

  void __set_offset(const int32_t val) {
    offset = val;
    __isset.offset = true;
  }

  void __set_num_nodes(const int32_t val) {
    num_nodes = val;
    __isset.num_nodes = true;
  }

  bool operator == (const TDsqlUri & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.pg_locations != rhs.__isset.pg_locations)
      return false;
    else if (__isset.pg_locations && !(pg_locations == rhs.pg_locations))
      return false;
    if (__isset.port != rhs.__isset.port)
      return false;
    else if (__isset.port && !(port == rhs.port))
      return false;
    if (__isset.url != rhs.__isset.url)
      return false;
    else if (__isset.url && !(url == rhs.url))
      return false;
    if (__isset.db_name != rhs.__isset.db_name)
      return false;
    else if (__isset.db_name && !(db_name == rhs.db_name))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    if (__isset.num_nodes != rhs.__isset.num_nodes)
      return false;
    else if (__isset.num_nodes && !(num_nodes == rhs.num_nodes))
      return false;
    return true;
  }
  bool operator != (const TDsqlUri &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDsqlUri & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDsqlUri &a, TDsqlUri &b);


class TPhoenixTable {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  TPhoenixTable() : port(0) {
  }

  virtual ~TPhoenixTable() throw() {}

  int32_t port;

  void __set_port(const int32_t val) {
    port = val;
  }

  bool operator == (const TPhoenixTable & rhs) const
  {
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const TPhoenixTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPhoenixTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPhoenixTable &a, TPhoenixTable &b);


class TStreamTable {
 public:

  static const char* ascii_fingerprint; // = "09E234EEAAB7732F568CAFA7D4AE0C23";
  static const uint8_t binary_fingerprint[16]; // = {0x09,0xE2,0x34,0xEE,0xAA,0xB7,0x73,0x2F,0x56,0x8C,0xAF,0xA7,0xD4,0xAE,0x0C,0x23};

  TStreamTable() : line_delim(0), field_delim(), escape_char(0), null_string() {
  }

  virtual ~TStreamTable() throw() {}

  int8_t line_delim;
  std::string field_delim;
  int8_t escape_char;
  std::string null_string;
  TDsqlUri uri;

  void __set_line_delim(const int8_t val) {
    line_delim = val;
  }

  void __set_field_delim(const std::string& val) {
    field_delim = val;
  }

  void __set_escape_char(const int8_t val) {
    escape_char = val;
  }

  void __set_null_string(const std::string& val) {
    null_string = val;
  }

  void __set_uri(const TDsqlUri& val) {
    uri = val;
  }

  bool operator == (const TStreamTable & rhs) const
  {
    if (!(line_delim == rhs.line_delim))
      return false;
    if (!(field_delim == rhs.field_delim))
      return false;
    if (!(escape_char == rhs.escape_char))
      return false;
    if (!(null_string == rhs.null_string))
      return false;
    if (!(uri == rhs.uri))
      return false;
    return true;
  }
  bool operator != (const TStreamTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStreamTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStreamTable &a, TStreamTable &b);

typedef struct _TTable__isset {
  _TTable__isset() : load_status(false), id(false), access_level(false), columns(false), clustering_columns(false), table_stats(false), table_type(false), hdfs_table(false), hbase_table(false), metastore_table(false), data_source_table(false), pg_table(false), stream_table(false), phoenix_table(false) {}
  bool load_status;
  bool id;
  bool access_level;
  bool columns;
  bool clustering_columns;
  bool table_stats;
  bool table_type;
  bool hdfs_table;
  bool hbase_table;
  bool metastore_table;
  bool data_source_table;
  bool pg_table;
  bool stream_table;
  bool phoenix_table;
} _TTable__isset;

class TTable {
 public:

  static const char* ascii_fingerprint; // = "93BD5F39259B96656070847913EB7E5F";
  static const uint8_t binary_fingerprint[16]; // = {0x93,0xBD,0x5F,0x39,0x25,0x9B,0x96,0x65,0x60,0x70,0x84,0x79,0x13,0xEB,0x7E,0x5F};

  TTable() : db_name(), tbl_name(), owner(), id(0), access_level((TAccessLevel::type)0), table_type((TTableType::type)0) {
  }

  virtual ~TTable() throw() {}

  std::string db_name;
  std::string tbl_name;
  std::string owner;
   ::impala::TStatus load_status;
   ::impala::TTableId id;
  TAccessLevel::type access_level;
  std::vector<TColumn>  columns;
  std::vector<TColumn>  clustering_columns;
  TTableStats table_stats;
  TTableType::type table_type;
  THdfsTable hdfs_table;
  THBaseTable hbase_table;
   ::Apache::Hadoop::Hive::Table metastore_table;
  TDataSourceTable data_source_table;
  TPGTable pg_table;
  TStreamTable stream_table;
  TPhoenixTable phoenix_table;

  _TTable__isset __isset;

  void __set_db_name(const std::string& val) {
    db_name = val;
  }

  void __set_tbl_name(const std::string& val) {
    tbl_name = val;
  }

  void __set_owner(const std::string& val) {
    owner = val;
  }

  void __set_load_status(const  ::impala::TStatus& val) {
    load_status = val;
    __isset.load_status = true;
  }

  void __set_id(const  ::impala::TTableId val) {
    id = val;
    __isset.id = true;
  }

  void __set_access_level(const TAccessLevel::type val) {
    access_level = val;
    __isset.access_level = true;
  }

  void __set_columns(const std::vector<TColumn> & val) {
    columns = val;
    __isset.columns = true;
  }

  void __set_clustering_columns(const std::vector<TColumn> & val) {
    clustering_columns = val;
    __isset.clustering_columns = true;
  }

  void __set_table_stats(const TTableStats& val) {
    table_stats = val;
    __isset.table_stats = true;
  }

  void __set_table_type(const TTableType::type val) {
    table_type = val;
    __isset.table_type = true;
  }

  void __set_hdfs_table(const THdfsTable& val) {
    hdfs_table = val;
    __isset.hdfs_table = true;
  }

  void __set_hbase_table(const THBaseTable& val) {
    hbase_table = val;
    __isset.hbase_table = true;
  }

  void __set_metastore_table(const  ::Apache::Hadoop::Hive::Table& val) {
    metastore_table = val;
    __isset.metastore_table = true;
  }

  void __set_data_source_table(const TDataSourceTable& val) {
    data_source_table = val;
    __isset.data_source_table = true;
  }

  void __set_pg_table(const TPGTable& val) {
    pg_table = val;
    __isset.pg_table = true;
  }

  void __set_stream_table(const TStreamTable& val) {
    stream_table = val;
    __isset.stream_table = true;
  }

  void __set_phoenix_table(const TPhoenixTable& val) {
    phoenix_table = val;
    __isset.phoenix_table = true;
  }

  bool operator == (const TTable & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (__isset.load_status != rhs.__isset.load_status)
      return false;
    else if (__isset.load_status && !(load_status == rhs.load_status))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.access_level != rhs.__isset.access_level)
      return false;
    else if (__isset.access_level && !(access_level == rhs.access_level))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.clustering_columns != rhs.__isset.clustering_columns)
      return false;
    else if (__isset.clustering_columns && !(clustering_columns == rhs.clustering_columns))
      return false;
    if (__isset.table_stats != rhs.__isset.table_stats)
      return false;
    else if (__isset.table_stats && !(table_stats == rhs.table_stats))
      return false;
    if (__isset.table_type != rhs.__isset.table_type)
      return false;
    else if (__isset.table_type && !(table_type == rhs.table_type))
      return false;
    if (__isset.hdfs_table != rhs.__isset.hdfs_table)
      return false;
    else if (__isset.hdfs_table && !(hdfs_table == rhs.hdfs_table))
      return false;
    if (__isset.hbase_table != rhs.__isset.hbase_table)
      return false;
    else if (__isset.hbase_table && !(hbase_table == rhs.hbase_table))
      return false;
    if (__isset.metastore_table != rhs.__isset.metastore_table)
      return false;
    else if (__isset.metastore_table && !(metastore_table == rhs.metastore_table))
      return false;
    if (__isset.data_source_table != rhs.__isset.data_source_table)
      return false;
    else if (__isset.data_source_table && !(data_source_table == rhs.data_source_table))
      return false;
    if (__isset.pg_table != rhs.__isset.pg_table)
      return false;
    else if (__isset.pg_table && !(pg_table == rhs.pg_table))
      return false;
    if (__isset.stream_table != rhs.__isset.stream_table)
      return false;
    else if (__isset.stream_table && !(stream_table == rhs.stream_table))
      return false;
    if (__isset.phoenix_table != rhs.__isset.phoenix_table)
      return false;
    else if (__isset.phoenix_table && !(phoenix_table == rhs.phoenix_table))
      return false;
    return true;
  }
  bool operator != (const TTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTable &a, TTable &b);

typedef struct _TIndexColumnElement__isset {
  _TIndexColumnElement__isset() : null_first(false) {}
  bool null_first;
} _TIndexColumnElement__isset;

class TIndexColumnElement {
 public:

  static const char* ascii_fingerprint; // = "4DC2E1C714CE2A88219E171951BC21F6";
  static const uint8_t binary_fingerprint[16]; // = {0x4D,0xC2,0xE1,0xC7,0x14,0xCE,0x2A,0x88,0x21,0x9E,0x17,0x19,0x51,0xBC,0x21,0xF6};

  TIndexColumnElement() : name(), is_asc(0), null_first(0) {
  }

  virtual ~TIndexColumnElement() throw() {}

  std::string name;
  bool is_asc;
  bool null_first;

  _TIndexColumnElement__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_is_asc(const bool val) {
    is_asc = val;
  }

  void __set_null_first(const bool val) {
    null_first = val;
    __isset.null_first = true;
  }

  bool operator == (const TIndexColumnElement & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(is_asc == rhs.is_asc))
      return false;
    if (__isset.null_first != rhs.__isset.null_first)
      return false;
    else if (__isset.null_first && !(null_first == rhs.null_first))
      return false;
    return true;
  }
  bool operator != (const TIndexColumnElement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIndexColumnElement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TIndexColumnElement &a, TIndexColumnElement &b);


class TIndex {
 public:

  static const char* ascii_fingerprint; // = "67F48EB40E1A86525410A0A98BC08CE9";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0xF4,0x8E,0xB4,0x0E,0x1A,0x86,0x52,0x54,0x10,0xA0,0xA9,0x8B,0xC0,0x8C,0xE9};

  TIndex() : db_name(), tbl_name(), idx_name(), type() {
  }

  virtual ~TIndex() throw() {}

  std::string db_name;
  std::string tbl_name;
  std::string idx_name;
  std::string type;
  std::vector<TIndexColumnElement>  columns;

  void __set_db_name(const std::string& val) {
    db_name = val;
  }

  void __set_tbl_name(const std::string& val) {
    tbl_name = val;
  }

  void __set_idx_name(const std::string& val) {
    idx_name = val;
  }

  void __set_type(const std::string& val) {
    type = val;
  }

  void __set_columns(const std::vector<TIndexColumnElement> & val) {
    columns = val;
  }

  bool operator == (const TIndex & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    if (!(idx_name == rhs.idx_name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(columns == rhs.columns))
      return false;
    return true;
  }
  bool operator != (const TIndex &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIndex & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TIndex &a, TIndex &b);

typedef struct _TDatabase__isset {
  _TDatabase__isset() : metastore_db(false), uri(false) {}
  bool metastore_db;
  bool uri;
} _TDatabase__isset;

class TDatabase {
 public:

  static const char* ascii_fingerprint; // = "B879D38C24452CACBA199E11B967EAB2";
  static const uint8_t binary_fingerprint[16]; // = {0xB8,0x79,0xD3,0x8C,0x24,0x45,0x2C,0xAC,0xBA,0x19,0x9E,0x11,0xB9,0x67,0xEA,0xB2};

  TDatabase() : db_name() {
  }

  virtual ~TDatabase() throw() {}

  std::string db_name;
   ::Apache::Hadoop::Hive::Database metastore_db;
  TDsqlUri uri;

  _TDatabase__isset __isset;

  void __set_db_name(const std::string& val) {
    db_name = val;
  }

  void __set_metastore_db(const  ::Apache::Hadoop::Hive::Database& val) {
    metastore_db = val;
    __isset.metastore_db = true;
  }

  void __set_uri(const TDsqlUri& val) {
    uri = val;
    __isset.uri = true;
  }

  bool operator == (const TDatabase & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (__isset.metastore_db != rhs.__isset.metastore_db)
      return false;
    else if (__isset.metastore_db && !(metastore_db == rhs.metastore_db))
      return false;
    if (__isset.uri != rhs.__isset.uri)
      return false;
    else if (__isset.uri && !(uri == rhs.uri))
      return false;
    return true;
  }
  bool operator != (const TDatabase &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDatabase & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDatabase &a, TDatabase &b);


class TRole {
 public:

  static const char* ascii_fingerprint; // = "6AB241362403A4E30F9D3B91873CCEF0";
  static const uint8_t binary_fingerprint[16]; // = {0x6A,0xB2,0x41,0x36,0x24,0x03,0xA4,0xE3,0x0F,0x9D,0x3B,0x91,0x87,0x3C,0xCE,0xF0};

  TRole() : role_name(), role_id(0) {
  }

  virtual ~TRole() throw() {}

  std::string role_name;
  int32_t role_id;
  std::vector<std::string>  grant_groups;

  void __set_role_name(const std::string& val) {
    role_name = val;
  }

  void __set_role_id(const int32_t val) {
    role_id = val;
  }

  void __set_grant_groups(const std::vector<std::string> & val) {
    grant_groups = val;
  }

  bool operator == (const TRole & rhs) const
  {
    if (!(role_name == rhs.role_name))
      return false;
    if (!(role_id == rhs.role_id))
      return false;
    if (!(grant_groups == rhs.grant_groups))
      return false;
    return true;
  }
  bool operator != (const TRole &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRole & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TRole &a, TRole &b);

typedef struct _TPrivilege__isset {
  _TPrivilege__isset() : role_id(false), server_name(false), db_name(false), table_name(false), uri(false), create_time_ms(false), column_name(false) {}
  bool role_id;
  bool server_name;
  bool db_name;
  bool table_name;
  bool uri;
  bool create_time_ms;
  bool column_name;
} _TPrivilege__isset;

class TPrivilege {
 public:

  static const char* ascii_fingerprint; // = "CC14D3F72B1FF1AA701B65CD923EA5FF";
  static const uint8_t binary_fingerprint[16]; // = {0xCC,0x14,0xD3,0xF7,0x2B,0x1F,0xF1,0xAA,0x70,0x1B,0x65,0xCD,0x92,0x3E,0xA5,0xFF};

  TPrivilege() : privilege_name(), privilege_level((TPrivilegeLevel::type)0), scope((TPrivilegeScope::type)0), has_grant_opt(0), role_id(0), server_name(), db_name(), table_name(), uri(), create_time_ms(0), column_name() {
  }

  virtual ~TPrivilege() throw() {}

  std::string privilege_name;
  TPrivilegeLevel::type privilege_level;
  TPrivilegeScope::type scope;
  bool has_grant_opt;
  int32_t role_id;
  std::string server_name;
  std::string db_name;
  std::string table_name;
  std::string uri;
  int64_t create_time_ms;
  std::string column_name;

  _TPrivilege__isset __isset;

  void __set_privilege_name(const std::string& val) {
    privilege_name = val;
  }

  void __set_privilege_level(const TPrivilegeLevel::type val) {
    privilege_level = val;
  }

  void __set_scope(const TPrivilegeScope::type val) {
    scope = val;
  }

  void __set_has_grant_opt(const bool val) {
    has_grant_opt = val;
  }

  void __set_role_id(const int32_t val) {
    role_id = val;
    __isset.role_id = true;
  }

  void __set_server_name(const std::string& val) {
    server_name = val;
    __isset.server_name = true;
  }

  void __set_db_name(const std::string& val) {
    db_name = val;
    __isset.db_name = true;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
    __isset.table_name = true;
  }

  void __set_uri(const std::string& val) {
    uri = val;
    __isset.uri = true;
  }

  void __set_create_time_ms(const int64_t val) {
    create_time_ms = val;
    __isset.create_time_ms = true;
  }

  void __set_column_name(const std::string& val) {
    column_name = val;
    __isset.column_name = true;
  }

  bool operator == (const TPrivilege & rhs) const
  {
    if (!(privilege_name == rhs.privilege_name))
      return false;
    if (!(privilege_level == rhs.privilege_level))
      return false;
    if (!(scope == rhs.scope))
      return false;
    if (!(has_grant_opt == rhs.has_grant_opt))
      return false;
    if (__isset.role_id != rhs.__isset.role_id)
      return false;
    else if (__isset.role_id && !(role_id == rhs.role_id))
      return false;
    if (__isset.server_name != rhs.__isset.server_name)
      return false;
    else if (__isset.server_name && !(server_name == rhs.server_name))
      return false;
    if (__isset.db_name != rhs.__isset.db_name)
      return false;
    else if (__isset.db_name && !(db_name == rhs.db_name))
      return false;
    if (__isset.table_name != rhs.__isset.table_name)
      return false;
    else if (__isset.table_name && !(table_name == rhs.table_name))
      return false;
    if (__isset.uri != rhs.__isset.uri)
      return false;
    else if (__isset.uri && !(uri == rhs.uri))
      return false;
    if (__isset.create_time_ms != rhs.__isset.create_time_ms)
      return false;
    else if (__isset.create_time_ms && !(create_time_ms == rhs.create_time_ms))
      return false;
    if (__isset.column_name != rhs.__isset.column_name)
      return false;
    else if (__isset.column_name && !(column_name == rhs.column_name))
      return false;
    return true;
  }
  bool operator != (const TPrivilege &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPrivilege & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPrivilege &a, TPrivilege &b);


class THdfsCachePool {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  THdfsCachePool() : pool_name() {
  }

  virtual ~THdfsCachePool() throw() {}

  std::string pool_name;

  void __set_pool_name(const std::string& val) {
    pool_name = val;
  }

  bool operator == (const THdfsCachePool & rhs) const
  {
    if (!(pool_name == rhs.pool_name))
      return false;
    return true;
  }
  bool operator != (const THdfsCachePool &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsCachePool & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsCachePool &a, THdfsCachePool &b);


class TCatalog {
 public:

  static const char* ascii_fingerprint; // = "9CFE4A6581B5B8EB11F5BBBCEFA07940";
  static const uint8_t binary_fingerprint[16]; // = {0x9C,0xFE,0x4A,0x65,0x81,0xB5,0xB8,0xEB,0x11,0xF5,0xBB,0xBC,0xEF,0xA0,0x79,0x40};

  TCatalog() {
  }

  virtual ~TCatalog() throw() {}

   ::impala::TUniqueId catalog_service_id;

  void __set_catalog_service_id(const  ::impala::TUniqueId& val) {
    catalog_service_id = val;
  }

  bool operator == (const TCatalog & rhs) const
  {
    if (!(catalog_service_id == rhs.catalog_service_id))
      return false;
    return true;
  }
  bool operator != (const TCatalog &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCatalog & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCatalog &a, TCatalog &b);

typedef struct _TCatalogObject__isset {
  _TCatalogObject__isset() : catalog(false), db(false), table(false), fn(false), data_source(false), role(false), privilege(false), cache_pool(false), index(false) {}
  bool catalog;
  bool db;
  bool table;
  bool fn;
  bool data_source;
  bool role;
  bool privilege;
  bool cache_pool;
  bool index;
} _TCatalogObject__isset;

class TCatalogObject {
 public:

  static const char* ascii_fingerprint; // = "A109746A41FAE72D9046FFE189A58463";
  static const uint8_t binary_fingerprint[16]; // = {0xA1,0x09,0x74,0x6A,0x41,0xFA,0xE7,0x2D,0x90,0x46,0xFF,0xE1,0x89,0xA5,0x84,0x63};

  TCatalogObject() : type((TCatalogObjectType::type)0), catalog_version(0) {
  }

  virtual ~TCatalogObject() throw() {}

  TCatalogObjectType::type type;
  int64_t catalog_version;
  TCatalog catalog;
  TDatabase db;
  TTable table;
   ::impala::TFunction fn;
  TDataSource data_source;
  TRole role;
  TPrivilege privilege;
  THdfsCachePool cache_pool;
  TIndex index;

  _TCatalogObject__isset __isset;

  void __set_type(const TCatalogObjectType::type val) {
    type = val;
  }

  void __set_catalog_version(const int64_t val) {
    catalog_version = val;
  }

  void __set_catalog(const TCatalog& val) {
    catalog = val;
    __isset.catalog = true;
  }

  void __set_db(const TDatabase& val) {
    db = val;
    __isset.db = true;
  }

  void __set_table(const TTable& val) {
    table = val;
    __isset.table = true;
  }

  void __set_fn(const  ::impala::TFunction& val) {
    fn = val;
    __isset.fn = true;
  }

  void __set_data_source(const TDataSource& val) {
    data_source = val;
    __isset.data_source = true;
  }

  void __set_role(const TRole& val) {
    role = val;
    __isset.role = true;
  }

  void __set_privilege(const TPrivilege& val) {
    privilege = val;
    __isset.privilege = true;
  }

  void __set_cache_pool(const THdfsCachePool& val) {
    cache_pool = val;
    __isset.cache_pool = true;
  }

  void __set_index(const TIndex& val) {
    index = val;
    __isset.index = true;
  }

  bool operator == (const TCatalogObject & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(catalog_version == rhs.catalog_version))
      return false;
    if (__isset.catalog != rhs.__isset.catalog)
      return false;
    else if (__isset.catalog && !(catalog == rhs.catalog))
      return false;
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.table != rhs.__isset.table)
      return false;
    else if (__isset.table && !(table == rhs.table))
      return false;
    if (__isset.fn != rhs.__isset.fn)
      return false;
    else if (__isset.fn && !(fn == rhs.fn))
      return false;
    if (__isset.data_source != rhs.__isset.data_source)
      return false;
    else if (__isset.data_source && !(data_source == rhs.data_source))
      return false;
    if (__isset.role != rhs.__isset.role)
      return false;
    else if (__isset.role && !(role == rhs.role))
      return false;
    if (__isset.privilege != rhs.__isset.privilege)
      return false;
    else if (__isset.privilege && !(privilege == rhs.privilege))
      return false;
    if (__isset.cache_pool != rhs.__isset.cache_pool)
      return false;
    else if (__isset.cache_pool && !(cache_pool == rhs.cache_pool))
      return false;
    if (__isset.index != rhs.__isset.index)
      return false;
    else if (__isset.index && !(index == rhs.index))
      return false;
    return true;
  }
  bool operator != (const TCatalogObject &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCatalogObject & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCatalogObject &a, TCatalogObject &b);

} // namespace

#endif
