/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Types_TYPES_H
#define Types_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace impala{

struct TPrimitiveType {
  enum type {
    INVALID_TYPE = 0,
    NULL_TYPE = 1,
    BOOLEAN = 2,
    TINYINT = 3,
    SMALLINT = 4,
    INT = 5,
    BIGINT = 6,
    FLOAT = 7,
    DOUBLE = 8,
    DATE = 9,
    DATETIME = 10,
    TIMESTAMP = 11,
    STRING = 12,
    BINARY = 13,
    DECIMAL = 14,
    CHAR = 15,
    VARCHAR = 16
  };
};

extern const std::map<int, const char*> _TPrimitiveType_VALUES_TO_NAMES;

struct TTypeNodeType {
  enum type {
    SCALAR = 0,
    ARRAY = 1,
    MAP = 2,
    STRUCT = 3
  };
};

extern const std::map<int, const char*> _TTypeNodeType_VALUES_TO_NAMES;

struct TStmtType {
  enum type {
    QUERY = 0,
    DDL = 1,
    DML = 2,
    EXPLAIN = 3,
    LOAD = 4,
    SET = 5,
    DELETE = 6,
    UPDATE = 7
  };
};

extern const std::map<int, const char*> _TStmtType_VALUES_TO_NAMES;

struct TExplainLevel {
  enum type {
    MINIMAL = 0,
    STANDARD = 1,
    EXTENDED = 2,
    VERBOSE = 3
  };
};

extern const std::map<int, const char*> _TExplainLevel_VALUES_TO_NAMES;

struct TFunctionCategory {
  enum type {
    SCALAR = 0,
    AGGREGATE = 1,
    ANALYTIC = 2
  };
};

extern const std::map<int, const char*> _TFunctionCategory_VALUES_TO_NAMES;

struct TFunctionBinaryType {
  enum type {
    BUILTIN = 0,
    HIVE = 1,
    NATIVE = 2,
    IR = 3
  };
};

extern const std::map<int, const char*> _TFunctionBinaryType_VALUES_TO_NAMES;

typedef int64_t TTimestamp;

typedef int32_t TPlanNodeId;

typedef int32_t TTupleId;

typedef int32_t TSlotId;

typedef int32_t TTableId;

typedef struct _TScalarType__isset {
  _TScalarType__isset() : len(false), precision(false), scale(false) {}
  bool len;
  bool precision;
  bool scale;
} _TScalarType__isset;

class TScalarType {
 public:

  static const char* ascii_fingerprint; // = "D68013E9233A1A7D7062FA286B362896";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0x80,0x13,0xE9,0x23,0x3A,0x1A,0x7D,0x70,0x62,0xFA,0x28,0x6B,0x36,0x28,0x96};

  TScalarType() : type((TPrimitiveType::type)0), len(0), precision(0), scale(0) {
  }

  virtual ~TScalarType() throw() {}

  TPrimitiveType::type type;
  int32_t len;
  int32_t precision;
  int32_t scale;

  _TScalarType__isset __isset;

  void __set_type(const TPrimitiveType::type val) {
    type = val;
  }

  void __set_len(const int32_t val) {
    len = val;
    __isset.len = true;
  }

  void __set_precision(const int32_t val) {
    precision = val;
    __isset.precision = true;
  }

  void __set_scale(const int32_t val) {
    scale = val;
    __isset.scale = true;
  }

  bool operator == (const TScalarType & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.len != rhs.__isset.len)
      return false;
    else if (__isset.len && !(len == rhs.len))
      return false;
    if (__isset.precision != rhs.__isset.precision)
      return false;
    else if (__isset.precision && !(precision == rhs.precision))
      return false;
    if (__isset.scale != rhs.__isset.scale)
      return false;
    else if (__isset.scale && !(scale == rhs.scale))
      return false;
    return true;
  }
  bool operator != (const TScalarType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScalarType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TScalarType &a, TScalarType &b);

typedef struct _TStructField__isset {
  _TStructField__isset() : comment(false) {}
  bool comment;
} _TStructField__isset;

class TStructField {
 public:

  static const char* ascii_fingerprint; // = "5B708A954C550ECA9C1A49D3C5CAFAB9";
  static const uint8_t binary_fingerprint[16]; // = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

  TStructField() : name(), comment() {
  }

  virtual ~TStructField() throw() {}

  std::string name;
  std::string comment;

  _TStructField__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  bool operator == (const TStructField & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const TStructField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStructField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStructField &a, TStructField &b);

typedef struct _TTypeNode__isset {
  _TTypeNode__isset() : scalar_type(false), struct_fields(false) {}
  bool scalar_type;
  bool struct_fields;
} _TTypeNode__isset;

class TTypeNode {
 public:

  static const char* ascii_fingerprint; // = "20F2BEB5930B41BB06CA311D86936C3E";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0xF2,0xBE,0xB5,0x93,0x0B,0x41,0xBB,0x06,0xCA,0x31,0x1D,0x86,0x93,0x6C,0x3E};

  TTypeNode() : type((TTypeNodeType::type)0) {
  }

  virtual ~TTypeNode() throw() {}

  TTypeNodeType::type type;
  TScalarType scalar_type;
  std::vector<TStructField>  struct_fields;

  _TTypeNode__isset __isset;

  void __set_type(const TTypeNodeType::type val) {
    type = val;
  }

  void __set_scalar_type(const TScalarType& val) {
    scalar_type = val;
    __isset.scalar_type = true;
  }

  void __set_struct_fields(const std::vector<TStructField> & val) {
    struct_fields = val;
    __isset.struct_fields = true;
  }

  bool operator == (const TTypeNode & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.scalar_type != rhs.__isset.scalar_type)
      return false;
    else if (__isset.scalar_type && !(scalar_type == rhs.scalar_type))
      return false;
    if (__isset.struct_fields != rhs.__isset.struct_fields)
      return false;
    else if (__isset.struct_fields && !(struct_fields == rhs.struct_fields))
      return false;
    return true;
  }
  bool operator != (const TTypeNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTypeNode &a, TTypeNode &b);

typedef struct _TColumnType__isset {
  _TColumnType__isset() : types(false) {}
  bool types;
} _TColumnType__isset;

class TColumnType {
 public:

  static const char* ascii_fingerprint; // = "AB152F6E2A595878B5FAFACB5FDAC6F0";
  static const uint8_t binary_fingerprint[16]; // = {0xAB,0x15,0x2F,0x6E,0x2A,0x59,0x58,0x78,0xB5,0xFA,0xFA,0xCB,0x5F,0xDA,0xC6,0xF0};

  TColumnType() {
  }

  virtual ~TColumnType() throw() {}

  std::vector<TTypeNode>  types;

  _TColumnType__isset __isset;

  void __set_types(const std::vector<TTypeNode> & val) {
    types = val;
    __isset.types = true;
  }

  bool operator == (const TColumnType & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const TColumnType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumnType &a, TColumnType &b);


class TNetworkAddress {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  TNetworkAddress() : hostname(), port(0) {
  }

  virtual ~TNetworkAddress() throw() {}

  std::string hostname;
  int32_t port;

  void __set_hostname(const std::string& val) {
    hostname = val;
  }

  void __set_port(const int32_t val) {
    port = val;
  }

  bool operator == (const TNetworkAddress & rhs) const
  {
    if (!(hostname == rhs.hostname))
      return false;
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const TNetworkAddress &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TNetworkAddress & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TNetworkAddress &a, TNetworkAddress &b);


class TUniqueId {
 public:

  static const char* ascii_fingerprint; // = "F33135321253DAEB67B0E79E416CA831";
  static const uint8_t binary_fingerprint[16]; // = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

  TUniqueId() : hi(0), lo(0) {
  }

  virtual ~TUniqueId() throw() {}

  int64_t hi;
  int64_t lo;

  void __set_hi(const int64_t val) {
    hi = val;
  }

  void __set_lo(const int64_t val) {
    lo = val;
  }

  bool operator == (const TUniqueId & rhs) const
  {
    if (!(hi == rhs.hi))
      return false;
    if (!(lo == rhs.lo))
      return false;
    return true;
  }
  bool operator != (const TUniqueId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUniqueId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUniqueId &a, TUniqueId &b);

typedef struct _TFunctionName__isset {
  _TFunctionName__isset() : db_name(false) {}
  bool db_name;
} _TFunctionName__isset;

class TFunctionName {
 public:

  static const char* ascii_fingerprint; // = "383E55F0D02199A3E52B9227E13A83A2";
  static const uint8_t binary_fingerprint[16]; // = {0x38,0x3E,0x55,0xF0,0xD0,0x21,0x99,0xA3,0xE5,0x2B,0x92,0x27,0xE1,0x3A,0x83,0xA2};

  TFunctionName() : db_name(), function_name() {
  }

  virtual ~TFunctionName() throw() {}

  std::string db_name;
  std::string function_name;

  _TFunctionName__isset __isset;

  void __set_db_name(const std::string& val) {
    db_name = val;
    __isset.db_name = true;
  }

  void __set_function_name(const std::string& val) {
    function_name = val;
  }

  bool operator == (const TFunctionName & rhs) const
  {
    if (__isset.db_name != rhs.__isset.db_name)
      return false;
    else if (__isset.db_name && !(db_name == rhs.db_name))
      return false;
    if (!(function_name == rhs.function_name))
      return false;
    return true;
  }
  bool operator != (const TFunctionName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFunctionName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFunctionName &a, TFunctionName &b);

typedef struct _TScalarFunction__isset {
  _TScalarFunction__isset() : prepare_fn_symbol(false), close_fn_symbol(false) {}
  bool prepare_fn_symbol;
  bool close_fn_symbol;
} _TScalarFunction__isset;

class TScalarFunction {
 public:

  static const char* ascii_fingerprint; // = "4BF81DD46A7371532E49811022D58D36";
  static const uint8_t binary_fingerprint[16]; // = {0x4B,0xF8,0x1D,0xD4,0x6A,0x73,0x71,0x53,0x2E,0x49,0x81,0x10,0x22,0xD5,0x8D,0x36};

  TScalarFunction() : symbol(), prepare_fn_symbol(), close_fn_symbol() {
  }

  virtual ~TScalarFunction() throw() {}

  std::string symbol;
  std::string prepare_fn_symbol;
  std::string close_fn_symbol;

  _TScalarFunction__isset __isset;

  void __set_symbol(const std::string& val) {
    symbol = val;
  }

  void __set_prepare_fn_symbol(const std::string& val) {
    prepare_fn_symbol = val;
    __isset.prepare_fn_symbol = true;
  }

  void __set_close_fn_symbol(const std::string& val) {
    close_fn_symbol = val;
    __isset.close_fn_symbol = true;
  }

  bool operator == (const TScalarFunction & rhs) const
  {
    if (!(symbol == rhs.symbol))
      return false;
    if (__isset.prepare_fn_symbol != rhs.__isset.prepare_fn_symbol)
      return false;
    else if (__isset.prepare_fn_symbol && !(prepare_fn_symbol == rhs.prepare_fn_symbol))
      return false;
    if (__isset.close_fn_symbol != rhs.__isset.close_fn_symbol)
      return false;
    else if (__isset.close_fn_symbol && !(close_fn_symbol == rhs.close_fn_symbol))
      return false;
    return true;
  }
  bool operator != (const TScalarFunction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScalarFunction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TScalarFunction &a, TScalarFunction &b);

typedef struct _TAggregateFunction__isset {
  _TAggregateFunction__isset() : serialize_fn_symbol(false), merge_fn_symbol(false), finalize_fn_symbol(false), get_value_fn_symbol(false), remove_fn_symbol(false), ignores_distinct(false) {}
  bool serialize_fn_symbol;
  bool merge_fn_symbol;
  bool finalize_fn_symbol;
  bool get_value_fn_symbol;
  bool remove_fn_symbol;
  bool ignores_distinct;
} _TAggregateFunction__isset;

class TAggregateFunction {
 public:

  static const char* ascii_fingerprint; // = "C19FE77DB28956A990E9DB268C62B104";
  static const uint8_t binary_fingerprint[16]; // = {0xC1,0x9F,0xE7,0x7D,0xB2,0x89,0x56,0xA9,0x90,0xE9,0xDB,0x26,0x8C,0x62,0xB1,0x04};

  TAggregateFunction() : update_fn_symbol(), init_fn_symbol(), serialize_fn_symbol(), merge_fn_symbol(), finalize_fn_symbol(), get_value_fn_symbol(), remove_fn_symbol(), ignores_distinct(0) {
  }

  virtual ~TAggregateFunction() throw() {}

  TColumnType intermediate_type;
  std::string update_fn_symbol;
  std::string init_fn_symbol;
  std::string serialize_fn_symbol;
  std::string merge_fn_symbol;
  std::string finalize_fn_symbol;
  std::string get_value_fn_symbol;
  std::string remove_fn_symbol;
  bool ignores_distinct;

  _TAggregateFunction__isset __isset;

  void __set_intermediate_type(const TColumnType& val) {
    intermediate_type = val;
  }

  void __set_update_fn_symbol(const std::string& val) {
    update_fn_symbol = val;
  }

  void __set_init_fn_symbol(const std::string& val) {
    init_fn_symbol = val;
  }

  void __set_serialize_fn_symbol(const std::string& val) {
    serialize_fn_symbol = val;
    __isset.serialize_fn_symbol = true;
  }

  void __set_merge_fn_symbol(const std::string& val) {
    merge_fn_symbol = val;
    __isset.merge_fn_symbol = true;
  }

  void __set_finalize_fn_symbol(const std::string& val) {
    finalize_fn_symbol = val;
    __isset.finalize_fn_symbol = true;
  }

  void __set_get_value_fn_symbol(const std::string& val) {
    get_value_fn_symbol = val;
    __isset.get_value_fn_symbol = true;
  }

  void __set_remove_fn_symbol(const std::string& val) {
    remove_fn_symbol = val;
    __isset.remove_fn_symbol = true;
  }

  void __set_ignores_distinct(const bool val) {
    ignores_distinct = val;
    __isset.ignores_distinct = true;
  }

  bool operator == (const TAggregateFunction & rhs) const
  {
    if (!(intermediate_type == rhs.intermediate_type))
      return false;
    if (!(update_fn_symbol == rhs.update_fn_symbol))
      return false;
    if (!(init_fn_symbol == rhs.init_fn_symbol))
      return false;
    if (__isset.serialize_fn_symbol != rhs.__isset.serialize_fn_symbol)
      return false;
    else if (__isset.serialize_fn_symbol && !(serialize_fn_symbol == rhs.serialize_fn_symbol))
      return false;
    if (__isset.merge_fn_symbol != rhs.__isset.merge_fn_symbol)
      return false;
    else if (__isset.merge_fn_symbol && !(merge_fn_symbol == rhs.merge_fn_symbol))
      return false;
    if (__isset.finalize_fn_symbol != rhs.__isset.finalize_fn_symbol)
      return false;
    else if (__isset.finalize_fn_symbol && !(finalize_fn_symbol == rhs.finalize_fn_symbol))
      return false;
    if (__isset.get_value_fn_symbol != rhs.__isset.get_value_fn_symbol)
      return false;
    else if (__isset.get_value_fn_symbol && !(get_value_fn_symbol == rhs.get_value_fn_symbol))
      return false;
    if (__isset.remove_fn_symbol != rhs.__isset.remove_fn_symbol)
      return false;
    else if (__isset.remove_fn_symbol && !(remove_fn_symbol == rhs.remove_fn_symbol))
      return false;
    if (__isset.ignores_distinct != rhs.__isset.ignores_distinct)
      return false;
    else if (__isset.ignores_distinct && !(ignores_distinct == rhs.ignores_distinct))
      return false;
    return true;
  }
  bool operator != (const TAggregateFunction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregateFunction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAggregateFunction &a, TAggregateFunction &b);

typedef struct _TFunction__isset {
  _TFunction__isset() : comment(false), signature(false), hdfs_location(false), scalar_fn(false), aggregate_fn(false), md5(false) {}
  bool comment;
  bool signature;
  bool hdfs_location;
  bool scalar_fn;
  bool aggregate_fn;
  bool md5;
} _TFunction__isset;

class TFunction {
 public:

  static const char* ascii_fingerprint; // = "8730A81FA44B4BAD2A51E82F5FA9C597";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0x30,0xA8,0x1F,0xA4,0x4B,0x4B,0xAD,0x2A,0x51,0xE8,0x2F,0x5F,0xA9,0xC5,0x97};

  TFunction() : binary_type((TFunctionBinaryType::type)0), has_var_args(0), comment(), signature(), hdfs_location(), md5() {
  }

  virtual ~TFunction() throw() {}

  TFunctionName name;
  TFunctionBinaryType::type binary_type;
  std::vector<TColumnType>  arg_types;
  TColumnType ret_type;
  bool has_var_args;
  std::string comment;
  std::string signature;
  std::string hdfs_location;
  TScalarFunction scalar_fn;
  TAggregateFunction aggregate_fn;
  std::string md5;

  _TFunction__isset __isset;

  void __set_name(const TFunctionName& val) {
    name = val;
  }

  void __set_binary_type(const TFunctionBinaryType::type val) {
    binary_type = val;
  }

  void __set_arg_types(const std::vector<TColumnType> & val) {
    arg_types = val;
  }

  void __set_ret_type(const TColumnType& val) {
    ret_type = val;
  }

  void __set_has_var_args(const bool val) {
    has_var_args = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_signature(const std::string& val) {
    signature = val;
    __isset.signature = true;
  }

  void __set_hdfs_location(const std::string& val) {
    hdfs_location = val;
    __isset.hdfs_location = true;
  }

  void __set_scalar_fn(const TScalarFunction& val) {
    scalar_fn = val;
    __isset.scalar_fn = true;
  }

  void __set_aggregate_fn(const TAggregateFunction& val) {
    aggregate_fn = val;
    __isset.aggregate_fn = true;
  }

  void __set_md5(const std::string& val) {
    md5 = val;
    __isset.md5 = true;
  }

  bool operator == (const TFunction & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(binary_type == rhs.binary_type))
      return false;
    if (!(arg_types == rhs.arg_types))
      return false;
    if (!(ret_type == rhs.ret_type))
      return false;
    if (!(has_var_args == rhs.has_var_args))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.signature != rhs.__isset.signature)
      return false;
    else if (__isset.signature && !(signature == rhs.signature))
      return false;
    if (__isset.hdfs_location != rhs.__isset.hdfs_location)
      return false;
    else if (__isset.hdfs_location && !(hdfs_location == rhs.hdfs_location))
      return false;
    if (__isset.scalar_fn != rhs.__isset.scalar_fn)
      return false;
    else if (__isset.scalar_fn && !(scalar_fn == rhs.scalar_fn))
      return false;
    if (__isset.aggregate_fn != rhs.__isset.aggregate_fn)
      return false;
    else if (__isset.aggregate_fn && !(aggregate_fn == rhs.aggregate_fn))
      return false;
    if (__isset.md5 != rhs.__isset.md5)
      return false;
    else if (__isset.md5 && !(md5 == rhs.md5))
      return false;
    return true;
  }
  bool operator != (const TFunction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFunction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFunction &a, TFunction &b);

} // namespace

#endif
