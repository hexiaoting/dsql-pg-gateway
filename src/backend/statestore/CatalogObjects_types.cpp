/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "CatalogObjects_types.h"

#include <algorithm>

namespace impala {

int _kTCatalogObjectTypeValues[] = {
  TCatalogObjectType::UNKNOWN,
  TCatalogObjectType::CATALOG,
  TCatalogObjectType::DATABASE,
  TCatalogObjectType::TABLE,
  TCatalogObjectType::VIEW,
  TCatalogObjectType::FUNCTION,
  TCatalogObjectType::DATA_SOURCE,
  TCatalogObjectType::ROLE,
  TCatalogObjectType::PRIVILEGE,
  TCatalogObjectType::HDFS_CACHE_POOL,
  TCatalogObjectType::INDEX,
  TCatalogObjectType::LIBRARY
};
const char* _kTCatalogObjectTypeNames[] = {
  "UNKNOWN",
  "CATALOG",
  "DATABASE",
  "TABLE",
  "VIEW",
  "FUNCTION",
  "DATA_SOURCE",
  "ROLE",
  "PRIVILEGE",
  "HDFS_CACHE_POOL",
  "INDEX",
  "LIBRARY"
};
const std::map<int, const char*> _TCatalogObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kTCatalogObjectTypeValues, _kTCatalogObjectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTableTypeValues[] = {
  TTableType::HDFS_TABLE,
  TTableType::HBASE_TABLE,
  TTableType::VIEW,
  TTableType::DATA_SOURCE_TABLE,
  TTableType::PG_TABLE,
  TTableType::STREAM_TABLE,
  TTableType::PHOENIX_TABLE
};
const char* _kTTableTypeNames[] = {
  "HDFS_TABLE",
  "HBASE_TABLE",
  "VIEW",
  "DATA_SOURCE_TABLE",
  "PG_TABLE",
  "STREAM_TABLE",
  "PHOENIX_TABLE"
};
const std::map<int, const char*> _TTableType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTTableTypeValues, _kTTableTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTHdfsFileFormatValues[] = {
  THdfsFileFormat::TEXT,
  THdfsFileFormat::RC_FILE,
  THdfsFileFormat::SEQUENCE_FILE,
  THdfsFileFormat::AVRO,
  THdfsFileFormat::PARQUET,
  THdfsFileFormat::NONE
};
const char* _kTHdfsFileFormatNames[] = {
  "TEXT",
  "RC_FILE",
  "SEQUENCE_FILE",
  "AVRO",
  "PARQUET",
  "NONE"
};
const std::map<int, const char*> _THdfsFileFormat_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTHdfsFileFormatValues, _kTHdfsFileFormatNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTHdfsCompressionValues[] = {
  THdfsCompression::NONE,
  THdfsCompression::DEFAULT,
  THdfsCompression::GZIP,
  THdfsCompression::DEFLATE,
  THdfsCompression::BZIP2,
  THdfsCompression::SNAPPY,
  THdfsCompression::SNAPPY_BLOCKED,
  THdfsCompression::LZO,
  THdfsCompression::LZ4
};
const char* _kTHdfsCompressionNames[] = {
  "NONE",
  "DEFAULT",
  "GZIP",
  "DEFLATE",
  "BZIP2",
  "SNAPPY",
  "SNAPPY_BLOCKED",
  "LZO",
  "LZ4"
};
const std::map<int, const char*> _THdfsCompression_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kTHdfsCompressionValues, _kTHdfsCompressionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTHdfsSeqCompressionModeValues[] = {
  THdfsSeqCompressionMode::RECORD,
  THdfsSeqCompressionMode::BLOCK
};
const char* _kTHdfsSeqCompressionModeNames[] = {
  "RECORD",
  "BLOCK"
};
const std::map<int, const char*> _THdfsSeqCompressionMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTHdfsSeqCompressionModeValues, _kTHdfsSeqCompressionModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTablePropertyTypeValues[] = {
  TTablePropertyType::TBL_PROPERTY,
  TTablePropertyType::SERDE_PROPERTY
};
const char* _kTTablePropertyTypeNames[] = {
  "TBL_PROPERTY",
  "SERDE_PROPERTY"
};
const std::map<int, const char*> _TTablePropertyType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTTablePropertyTypeValues, _kTTablePropertyTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAccessLevelValues[] = {
  TAccessLevel::NONE,
  TAccessLevel::READ_WRITE,
  TAccessLevel::READ_ONLY,
  TAccessLevel::WRITE_ONLY
};
const char* _kTAccessLevelNames[] = {
  "NONE",
  "READ_WRITE",
  "READ_ONLY",
  "WRITE_ONLY"
};
const std::map<int, const char*> _TAccessLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTAccessLevelValues, _kTAccessLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTUriTypeValues[] = {
  TUriType::HIVE,
  TUriType::PG,
  TUriType::STREAM,
  TUriType::PHOENIX
};
const char* _kTUriTypeNames[] = {
  "HIVE",
  "PG",
  "STREAM",
  "PHOENIX"
};
const std::map<int, const char*> _TUriType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTUriTypeValues, _kTUriTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTPrivilegeScopeValues[] = {
  TPrivilegeScope::SERVER,
  TPrivilegeScope::URI,
  TPrivilegeScope::DATABASE,
  TPrivilegeScope::TABLE,
  TPrivilegeScope::COLUMN
};
const char* _kTPrivilegeScopeNames[] = {
  "SERVER",
  "URI",
  "DATABASE",
  "TABLE",
  "COLUMN"
};
const std::map<int, const char*> _TPrivilegeScope_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTPrivilegeScopeValues, _kTPrivilegeScopeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTPrivilegeLevelValues[] = {
  TPrivilegeLevel::ALL,
  TPrivilegeLevel::INSERT,
  TPrivilegeLevel::SELECT
};
const char* _kTPrivilegeLevelNames[] = {
  "ALL",
  "INSERT",
  "SELECT"
};
const std::map<int, const char*> _TPrivilegeLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTPrivilegeLevelValues, _kTPrivilegeLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TPartitionKeyValue::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t TPartitionKeyValue::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t TPartitionKeyValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPartitionKeyValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPartitionKeyValue");

  ++fcnt;
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPartitionKeyValue &a, TPartitionKeyValue &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
}

const char* TTableName::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t TTableName::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t TTableName::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTableName");

  ++fcnt;
  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableName &a, TTableName &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
}

const char* TTableStats::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t TTableStats::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t TTableStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_rows = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          isset_num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_rows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTableStats");

  ++fcnt;
  xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableStats &a, TTableStats &b) {
  using ::std::swap;
  swap(a.num_rows, b.num_rows);
}

const char* TColumnStats::ascii_fingerprint = "D5FF58B203C57D2B1EF98050D612DB56";
const uint8_t TColumnStats::binary_fingerprint[16] = {0xD5,0xFF,0x58,0xB2,0x03,0xC5,0x7D,0x2B,0x1E,0xF9,0x80,0x50,0xD6,0x12,0xDB,0x56};

uint32_t TColumnStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_avg_size = false;
  bool isset_max_size = false;
  bool isset_num_distinct_values = false;
  bool isset_num_nulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avg_size);
          isset_avg_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_size);
          isset_max_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_distinct_values);
          isset_num_distinct_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_nulls);
          isset_num_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_avg_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_distinct_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TColumnStats");

  ++fcnt;
  xfer += oprot->writeFieldBegin("avg_size", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->avg_size);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("max_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->max_size);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("num_distinct_values", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_distinct_values);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("num_nulls", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->num_nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnStats &a, TColumnStats &b) {
  using ::std::swap;
  swap(a.avg_size, b.avg_size);
  swap(a.max_size, b.max_size);
  swap(a.num_distinct_values, b.num_distinct_values);
  swap(a.num_nulls, b.num_nulls);
}

const char* TIntermediateColumnStats::ascii_fingerprint = "F89B7426F451543B11701B02D64A9AF2";
const uint8_t TIntermediateColumnStats::binary_fingerprint[16] = {0xF8,0x9B,0x74,0x26,0xF4,0x51,0x54,0x3B,0x11,0x70,0x1B,0x02,0xD6,0x4A,0x9A,0xF2};

uint32_t TIntermediateColumnStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->intermediate_ndv);
          this->__isset.intermediate_ndv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ndv_encoded);
          this->__isset.is_ndv_encoded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_nulls);
          this->__isset.num_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_width);
          this->__isset.max_width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avg_width);
          this->__isset.avg_width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIntermediateColumnStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TIntermediateColumnStats");

  if (this->__isset.intermediate_ndv) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("intermediate_ndv", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->intermediate_ndv);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_ndv_encoded) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("is_ndv_encoded", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->is_ndv_encoded);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_nulls) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("num_nulls", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->num_nulls);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_width) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("max_width", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->max_width);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.avg_width) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("avg_width", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->avg_width);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_rows) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->num_rows);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIntermediateColumnStats &a, TIntermediateColumnStats &b) {
  using ::std::swap;
  swap(a.intermediate_ndv, b.intermediate_ndv);
  swap(a.is_ndv_encoded, b.is_ndv_encoded);
  swap(a.num_nulls, b.num_nulls);
  swap(a.max_width, b.max_width);
  swap(a.avg_width, b.avg_width);
  swap(a.num_rows, b.num_rows);
  swap(a.__isset, b.__isset);
}

const char* TPartitionStats::ascii_fingerprint = "98BD569BF2AD25B1B80BFCECFCFE3E8D";
const uint8_t TPartitionStats::binary_fingerprint[16] = {0x98,0xBD,0x56,0x9B,0xF2,0xAD,0x25,0xB1,0xB8,0x0B,0xFC,0xEC,0xFC,0xFE,0x3E,0x8D};

uint32_t TPartitionStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_stats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stats.read(iprot);
          isset_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->intermediate_col_stats.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              TIntermediateColumnStats& _val6 = this->intermediate_col_stats[_key5];
              xfer += _val6.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.intermediate_col_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_stats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPartitionStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPartitionStats");

  ++fcnt;
  xfer += oprot->writeFieldBegin("stats", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stats.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.intermediate_col_stats) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("intermediate_col_stats", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intermediate_col_stats.size()));
      std::map<std::string, TIntermediateColumnStats> ::const_iterator _iter7;
      for (_iter7 = this->intermediate_col_stats.begin(); _iter7 != this->intermediate_col_stats.end(); ++_iter7)
      {
        xfer += oprot->writeString(_iter7->first);
        xfer += _iter7->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPartitionStats &a, TPartitionStats &b) {
  using ::std::swap;
  swap(a.stats, b.stats);
  swap(a.intermediate_col_stats, b.intermediate_col_stats);
  swap(a.__isset, b.__isset);
}

const char* TColumn::ascii_fingerprint = "6FDCB72B96621B6C2A51DC13B6AA172A";
const uint8_t TColumn::binary_fingerprint[16] = {0x6F,0xDC,0xB7,0x2B,0x96,0x62,0x1B,0x6C,0x2A,0x51,0xDC,0x13,0xB6,0xAA,0x17,0x2A};

uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnName = false;
  bool isset_columnType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          isset_columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->columnType.read(iprot);
          isset_columnType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->col_stats.read(iprot);
          this->__isset.col_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->position);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_hbase_column);
          this->__isset.is_hbase_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_family);
          this->__isset.column_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_qualifier);
          this->__isset.column_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_binary);
          this->__isset.is_binary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TColumn");

  ++fcnt;
  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("columnType", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->columnType.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_stats) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("col_stats", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->col_stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.position) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->position);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_hbase_column) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("is_hbase_column", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_hbase_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_family) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("column_family", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->column_family);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_qualifier) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("column_qualifier", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->column_qualifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_binary) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("is_binary", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_binary);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.columnName, b.columnName);
  swap(a.columnType, b.columnType);
  swap(a.comment, b.comment);
  swap(a.col_stats, b.col_stats);
  swap(a.position, b.position);
  swap(a.is_hbase_column, b.is_hbase_column);
  swap(a.column_family, b.column_family);
  swap(a.column_qualifier, b.column_qualifier);
  swap(a.is_binary, b.is_binary);
  swap(a.__isset, b.__isset);
}

const char* THdfsFileBlock::ascii_fingerprint = "11720BFD3AD04B8A78FD5DCBA5CCDEFF";
const uint8_t THdfsFileBlock::binary_fingerprint[16] = {0x11,0x72,0x0B,0xFD,0x3A,0xD0,0x4B,0x8A,0x78,0xFD,0x5D,0xCB,0xA5,0xCC,0xDE,0xFF};

uint32_t THdfsFileBlock::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_offset = false;
  bool isset_length = false;
  bool isset_replica_host_idxs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          isset_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->length);
          isset_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->replica_host_idxs.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->replica_host_idxs.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += iprot->readI32(this->replica_host_idxs[_i12]);
            }
            xfer += iprot->readListEnd();
          }
          isset_replica_host_idxs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->disk_ids.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->disk_ids.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += iprot->readI32(this->disk_ids[_i17]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.disk_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->is_replica_cached.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->is_replica_cached.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += iprot->readBool(this->is_replica_cached[_i22]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.is_replica_cached = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_offset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_length)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_replica_host_idxs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THdfsFileBlock::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THdfsFileBlock");

  ++fcnt;
  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->length);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("replica_host_idxs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->replica_host_idxs.size()));
    std::vector<int32_t> ::const_iterator _iter23;
    for (_iter23 = this->replica_host_idxs.begin(); _iter23 != this->replica_host_idxs.end(); ++_iter23)
    {
      xfer += oprot->writeI32((*_iter23));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.disk_ids) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("disk_ids", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->disk_ids.size()));
      std::vector<int32_t> ::const_iterator _iter24;
      for (_iter24 = this->disk_ids.begin(); _iter24 != this->disk_ids.end(); ++_iter24)
      {
        xfer += oprot->writeI32((*_iter24));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_replica_cached) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("is_replica_cached", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->is_replica_cached.size()));
      std::vector<bool> ::const_iterator _iter25;
      for (_iter25 = this->is_replica_cached.begin(); _iter25 != this->is_replica_cached.end(); ++_iter25)
      {
        xfer += oprot->writeBool((*_iter25));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THdfsFileBlock &a, THdfsFileBlock &b) {
  using ::std::swap;
  swap(a.offset, b.offset);
  swap(a.length, b.length);
  swap(a.replica_host_idxs, b.replica_host_idxs);
  swap(a.disk_ids, b.disk_ids);
  swap(a.is_replica_cached, b.is_replica_cached);
  swap(a.__isset, b.__isset);
}

const char* THdfsFileDesc::ascii_fingerprint = "425A3488D3AEC10B76A7420BF5474B94";
const uint8_t THdfsFileDesc::binary_fingerprint[16] = {0x42,0x5A,0x34,0x88,0xD3,0xAE,0xC1,0x0B,0x76,0xA7,0x42,0x0B,0xF5,0x47,0x4B,0x94};

uint32_t THdfsFileDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_file_name = false;
  bool isset_length = false;
  bool isset_compression = false;
  bool isset_last_modification_time = false;
  bool isset_file_blocks = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_name);
          isset_file_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->length);
          isset_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast26;
          xfer += iprot->readI32(ecast26);
          this->compression = (THdfsCompression::type)ecast26;
          isset_compression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_modification_time);
          isset_last_modification_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->file_blocks.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->file_blocks.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += this->file_blocks[_i31].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_file_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_file_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_length)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compression)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_last_modification_time)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file_blocks)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THdfsFileDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THdfsFileDesc");

  ++fcnt;
  xfer += oprot->writeFieldBegin("file_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->file_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->length);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("compression", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->compression);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("last_modification_time", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->last_modification_time);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("file_blocks", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->file_blocks.size()));
    std::vector<THdfsFileBlock> ::const_iterator _iter32;
    for (_iter32 = this->file_blocks.begin(); _iter32 != this->file_blocks.end(); ++_iter32)
    {
      xfer += (*_iter32).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THdfsFileDesc &a, THdfsFileDesc &b) {
  using ::std::swap;
  swap(a.file_name, b.file_name);
  swap(a.length, b.length);
  swap(a.compression, b.compression);
  swap(a.last_modification_time, b.last_modification_time);
  swap(a.file_blocks, b.file_blocks);
}

const char* THdfsPartition::ascii_fingerprint = "09B6E2E7D9D39CCA06A0557A02D5111D";
const uint8_t THdfsPartition::binary_fingerprint[16] = {0x09,0xB6,0xE2,0xE7,0xD9,0xD3,0x9C,0xCA,0x06,0xA0,0x55,0x7A,0x02,0xD5,0x11,0x1D};

uint32_t THdfsPartition::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lineDelim = false;
  bool isset_fieldDelim = false;
  bool isset_collectionDelim = false;
  bool isset_mapKeyDelim = false;
  bool isset_escapeChar = false;
  bool isset_fileFormat = false;
  bool isset_blockSize = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->lineDelim);
          isset_lineDelim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->fieldDelim);
          isset_fieldDelim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->collectionDelim);
          isset_collectionDelim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mapKeyDelim);
          isset_mapKeyDelim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->escapeChar);
          isset_escapeChar = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast33;
          xfer += iprot->readI32(ecast33);
          this->fileFormat = (THdfsFileFormat::type)ecast33;
          isset_fileFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
/*hwt        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionKeyExprs.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            xfer += iprot->readListBegin(_etype37, _size34);
            this->partitionKeyExprs.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += this->partitionKeyExprs[_i38].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionKeyExprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        */
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blockSize);
          isset_blockSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->file_desc.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _etype42;
            xfer += iprot->readListBegin(_etype42, _size39);
            this->file_desc.resize(_size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              xfer += this->file_desc[_i43].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.file_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast44;
          xfer += iprot->readI32(ecast44);
          this->access_level = (TAccessLevel::type)ecast44;
          this->__isset.access_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stats.read(iprot);
          this->__isset.stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_marked_cached);
          this->__isset.is_marked_cached = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->hms_parameters.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _ktype46;
            ::apache::thrift::protocol::TType _vtype47;
            xfer += iprot->readMapBegin(_ktype46, _vtype47, _size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              std::string _key50;
              xfer += iprot->readString(_key50);
              std::string& _val51 = this->hms_parameters[_key50];
              xfer += iprot->readString(_val51);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.hms_parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lineDelim)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fieldDelim)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_collectionDelim)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mapKeyDelim)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_escapeChar)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fileFormat)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_blockSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THdfsPartition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THdfsPartition");

  ++fcnt;
  xfer += oprot->writeFieldBegin("lineDelim", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->lineDelim);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("fieldDelim", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->fieldDelim);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("collectionDelim", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->collectionDelim);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("mapKeyDelim", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->mapKeyDelim);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("escapeChar", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->escapeChar);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("fileFormat", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->fileFormat);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("partitionKeyExprs", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionKeyExprs.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter52;
    for (_iter52 = this->partitionKeyExprs.begin(); _iter52 != this->partitionKeyExprs.end(); ++_iter52)
    {
      /* hwt
      xfer += (*_iter52).write(oprot);
      */
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("blockSize", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->blockSize);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.file_desc) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("file_desc", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->file_desc.size()));
      std::vector<THdfsFileDesc> ::const_iterator _iter53;
      for (_iter53 = this->file_desc.begin(); _iter53 != this->file_desc.end(); ++_iter53)
      {
        xfer += (*_iter53).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.access_level) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("access_level", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32((int32_t)this->access_level);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stats) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("stats", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_marked_cached) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("is_marked_cached", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_marked_cached);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hms_parameters) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("hms_parameters", ::apache::thrift::protocol::T_MAP, 15);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hms_parameters.size()));
      std::map<std::string, std::string> ::const_iterator _iter54;
      for (_iter54 = this->hms_parameters.begin(); _iter54 != this->hms_parameters.end(); ++_iter54)
      {
        xfer += oprot->writeString(_iter54->first);
        xfer += oprot->writeString(_iter54->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THdfsPartition &a, THdfsPartition &b) {
  using ::std::swap;
  swap(a.lineDelim, b.lineDelim);
  swap(a.fieldDelim, b.fieldDelim);
  swap(a.collectionDelim, b.collectionDelim);
  swap(a.mapKeyDelim, b.mapKeyDelim);
  swap(a.escapeChar, b.escapeChar);
  swap(a.fileFormat, b.fileFormat);
  swap(a.partitionKeyExprs, b.partitionKeyExprs);
  swap(a.blockSize, b.blockSize);
  swap(a.file_desc, b.file_desc);
  swap(a.location, b.location);
  swap(a.access_level, b.access_level);
  swap(a.stats, b.stats);
  swap(a.is_marked_cached, b.is_marked_cached);
  swap(a.id, b.id);
  swap(a.hms_parameters, b.hms_parameters);
  swap(a.__isset, b.__isset);
}

const char* THdfsTable::ascii_fingerprint = "21B5F8E37E85CF1B063E6E97DD6FE936";
const uint8_t THdfsTable::binary_fingerprint[16] = {0x21,0xB5,0xF8,0xE3,0x7E,0x85,0xCF,0x1B,0x06,0x3E,0x6E,0x97,0xDD,0x6F,0xE9,0x36};

uint32_t THdfsTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hdfsBaseDir = false;
  bool isset_colNames = false;
  bool isset_nullPartitionKeyValue = false;
  bool isset_nullColumnValue = false;
  bool isset_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfsBaseDir);
          isset_hdfsBaseDir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colNames.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _etype58;
            xfer += iprot->readListBegin(_etype58, _size55);
            this->colNames.resize(_size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              xfer += iprot->readString(this->colNames[_i59]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nullPartitionKeyValue);
          isset_nullPartitionKeyValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nullColumnValue);
          isset_nullColumnValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avroSchema);
          this->__isset.avroSchema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->partitions.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _ktype61;
            ::apache::thrift::protocol::TType _vtype62;
            xfer += iprot->readMapBegin(_ktype61, _vtype62, _size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              int64_t _key65;
              xfer += iprot->readI64(_key65);
              THdfsPartition& _val66 = this->partitions[_key65];
              xfer += _val66.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->network_addresses.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->network_addresses.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += this->network_addresses[_i71].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.network_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->multiple_filesystems);
          this->__isset.multiple_filesystems = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hdfsBaseDir)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullPartitionKeyValue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullColumnValue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THdfsTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THdfsTable");

  ++fcnt;
  xfer += oprot->writeFieldBegin("hdfsBaseDir", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hdfsBaseDir);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("colNames", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->colNames.size()));
    std::vector<std::string> ::const_iterator _iter72;
    for (_iter72 = this->colNames.begin(); _iter72 != this->colNames.end(); ++_iter72)
    {
      xfer += oprot->writeString((*_iter72));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("nullPartitionKeyValue", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->nullPartitionKeyValue);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::map<int64_t, THdfsPartition> ::const_iterator _iter73;
    for (_iter73 = this->partitions.begin(); _iter73 != this->partitions.end(); ++_iter73)
    {
      xfer += oprot->writeI64(_iter73->first);
      xfer += _iter73->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("nullColumnValue", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nullColumnValue);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.avroSchema) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("avroSchema", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->avroSchema);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_addresses) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("network_addresses", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_addresses.size()));
      std::vector< ::impala::TNetworkAddress> ::const_iterator _iter74;
      for (_iter74 = this->network_addresses.begin(); _iter74 != this->network_addresses.end(); ++_iter74)
      {
        xfer += (*_iter74).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.multiple_filesystems) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("multiple_filesystems", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->multiple_filesystems);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THdfsTable &a, THdfsTable &b) {
  using ::std::swap;
  swap(a.hdfsBaseDir, b.hdfsBaseDir);
  swap(a.colNames, b.colNames);
  swap(a.nullPartitionKeyValue, b.nullPartitionKeyValue);
  swap(a.nullColumnValue, b.nullColumnValue);
  swap(a.avroSchema, b.avroSchema);
  swap(a.partitions, b.partitions);
  swap(a.network_addresses, b.network_addresses);
  swap(a.multiple_filesystems, b.multiple_filesystems);
  swap(a.__isset, b.__isset);
}

const char* THBaseTable::ascii_fingerprint = "1020D6DBCD4B2FB077A077715FEA851B";
const uint8_t THBaseTable::binary_fingerprint[16] = {0x10,0x20,0xD6,0xDB,0xCD,0x4B,0x2F,0xB0,0x77,0xA0,0x77,0x71,0x5F,0xEA,0x85,0x1B};

uint32_t THBaseTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableName = false;
  bool isset_families = false;
  bool isset_qualifiers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->families.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _etype78;
            xfer += iprot->readListBegin(_etype78, _size75);
            this->families.resize(_size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              xfer += iprot->readString(this->families[_i79]);
            }
            xfer += iprot->readListEnd();
          }
          isset_families = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->qualifiers.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _etype83;
            xfer += iprot->readListBegin(_etype83, _size80);
            this->qualifiers.resize(_size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              xfer += iprot->readString(this->qualifiers[_i84]);
            }
            xfer += iprot->readListEnd();
          }
          isset_qualifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->binary_encoded.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _etype88;
            xfer += iprot->readListBegin(_etype88, _size85);
            this->binary_encoded.resize(_size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              xfer += iprot->readBool(this->binary_encoded[_i89]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.binary_encoded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_families)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifiers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THBaseTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THBaseTable");

  ++fcnt;
  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("families", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->families.size()));
    std::vector<std::string> ::const_iterator _iter90;
    for (_iter90 = this->families.begin(); _iter90 != this->families.end(); ++_iter90)
    {
      xfer += oprot->writeString((*_iter90));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("qualifiers", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->qualifiers.size()));
    std::vector<std::string> ::const_iterator _iter91;
    for (_iter91 = this->qualifiers.begin(); _iter91 != this->qualifiers.end(); ++_iter91)
    {
      xfer += oprot->writeString((*_iter91));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.binary_encoded) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("binary_encoded", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->binary_encoded.size()));
      std::vector<bool> ::const_iterator _iter92;
      for (_iter92 = this->binary_encoded.begin(); _iter92 != this->binary_encoded.end(); ++_iter92)
      {
        xfer += oprot->writeBool((*_iter92));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THBaseTable &a, THBaseTable &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
  swap(a.families, b.families);
  swap(a.qualifiers, b.qualifiers);
  swap(a.binary_encoded, b.binary_encoded);
  swap(a.__isset, b.__isset);
}

const char* TDataSource::ascii_fingerprint = "C93D890311F28844166CF6E571EB3AC2";
const uint8_t TDataSource::binary_fingerprint[16] = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};

uint32_t TDataSource::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_hdfs_location = false;
  bool isset_class_name = false;
  bool isset_api_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfs_location);
          isset_hdfs_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->class_name);
          isset_class_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->api_version);
          isset_api_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hdfs_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_class_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_api_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDataSource::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TDataSource");

  ++fcnt;
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("hdfs_location", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hdfs_location);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("class_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->class_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("api_version", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->api_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataSource &a, TDataSource &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.hdfs_location, b.hdfs_location);
  swap(a.class_name, b.class_name);
  swap(a.api_version, b.api_version);
}

const char* TDataSourceTable::ascii_fingerprint = "7ADC8F063F12245EDF20DEB68DBB1D55";
const uint8_t TDataSourceTable::binary_fingerprint[16] = {0x7A,0xDC,0x8F,0x06,0x3F,0x12,0x24,0x5E,0xDF,0x20,0xDE,0xB6,0x8D,0xBB,0x1D,0x55};

uint32_t TDataSourceTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data_source = false;
  bool isset_init_string = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_source.read(iprot);
          isset_data_source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->init_string);
          isset_init_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data_source)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_init_string)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDataSourceTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TDataSourceTable");

  ++fcnt;
  xfer += oprot->writeFieldBegin("data_source", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->data_source.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("init_string", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->init_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataSourceTable &a, TDataSourceTable &b) {
  using ::std::swap;
  swap(a.data_source, b.data_source);
  swap(a.init_string, b.init_string);
}

const char* TPGTablet::ascii_fingerprint = "B87B6F57864ED98AD1BA3E1CD6F87805";
const uint8_t TPGTablet::binary_fingerprint[16] = {0xB8,0x7B,0x6F,0x57,0x86,0x4E,0xD9,0x8A,0xD1,0xBA,0x3E,0x1C,0xD6,0xF8,0x78,0x05};

uint32_t TPGTablet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_addrs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->addrs.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->addrs.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += this->addrs[_i97].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_addrs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_addrs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPGTablet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPGTablet");

  ++fcnt;
  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("addrs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->addrs.size()));
    std::vector< ::impala::TNetworkAddress> ::const_iterator _iter98;
    for (_iter98 = this->addrs.begin(); _iter98 != this->addrs.end(); ++_iter98)
    {
      xfer += (*_iter98).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPGTablet &a, TPGTablet &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.addrs, b.addrs);
}

const char* TPGPartition::ascii_fingerprint = "E6693F194F8AF4C7A4CCF6A470F3C29E";
const uint8_t TPGPartition::binary_fingerprint[16] = {0xE6,0x69,0x3F,0x19,0x4F,0x8A,0xF4,0xC7,0xA4,0xCC,0xF6,0xA4,0x70,0xF3,0xC2,0x9E};

uint32_t TPGPartition::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitionKeyExprs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionKeyExprs.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readListBegin(_etype102, _size99);
            this->partitionKeyExprs.resize(_size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              xfer += this->partitionKeyExprs[_i103].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionKeyExprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tablets.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->tablets.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += this->tablets[_i108].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tablets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stats.read(iprot);
          this->__isset.stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size109;
            ::apache::thrift::protocol::TType _ktype110;
            ::apache::thrift::protocol::TType _vtype111;
            xfer += iprot->readMapBegin(_ktype110, _vtype111, _size109);
            uint32_t _i113;
            for (_i113 = 0; _i113 < _size109; ++_i113)
            {
              std::string _key114;
              xfer += iprot->readString(_key114);
              std::string& _val115 = this->parameters[_key114];
              xfer += iprot->readString(_val115);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitionKeyExprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPGPartition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPGPartition");

  ++fcnt;
  xfer += oprot->writeFieldBegin("partitionKeyExprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionKeyExprs.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter116;
    for (_iter116 = this->partitionKeyExprs.begin(); _iter116 != this->partitionKeyExprs.end(); ++_iter116)
    {
      xfer += (*_iter116).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tablets) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("tablets", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tablets.size()));
      std::vector<TPGTablet> ::const_iterator _iter117;
      for (_iter117 = this->tablets.begin(); _iter117 != this->tablets.end(); ++_iter117)
      {
        xfer += (*_iter117).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stats) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("stats", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parameters) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
      std::map<std::string, std::string> ::const_iterator _iter118;
      for (_iter118 = this->parameters.begin(); _iter118 != this->parameters.end(); ++_iter118)
      {
        xfer += oprot->writeString(_iter118->first);
        xfer += oprot->writeString(_iter118->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPGPartition &a, TPGPartition &b) {
  using ::std::swap;
  swap(a.partitionKeyExprs, b.partitionKeyExprs);
  swap(a.tablets, b.tablets);
  swap(a.stats, b.stats);
  swap(a.id, b.id);
  swap(a.parameters, b.parameters);
  swap(a.__isset, b.__isset);
}

const char* TPGTable::ascii_fingerprint = "E62633871D0FAFFE579ED97505D34EB1";
const uint8_t TPGTable::binary_fingerprint[16] = {0xE6,0x26,0x33,0x87,0x1D,0x0F,0xAF,0xFE,0x57,0x9E,0xD9,0x75,0x05,0xD3,0x4E,0xB1};

uint32_t TPGTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableName = false;
  bool isset_owner = false;
  bool isset_partitions = false;
  bool isset_partition_columns = false;
  bool isset_sql = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->partitions.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _ktype120;
            ::apache::thrift::protocol::TType _vtype121;
            xfer += iprot->readMapBegin(_ktype120, _vtype121, _size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              int64_t _key124;
              xfer += iprot->readI64(_key124);
              TPGPartition& _val125 = this->partitions[_key124];
              xfer += _val125.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_columns.clear();
            uint32_t _size126;
            ::apache::thrift::protocol::TType _etype129;
            xfer += iprot->readListBegin(_etype129, _size126);
            this->partition_columns.resize(_size126);
            uint32_t _i130;
            for (_i130 = 0; _i130 < _size126; ++_i130)
            {
              xfer += this->partition_columns[_i130].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          isset_sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sql)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPGTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPGTable");

  ++fcnt;
  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::map<int64_t, TPGPartition> ::const_iterator _iter131;
    for (_iter131 = this->partitions.begin(); _iter131 != this->partitions.end(); ++_iter131)
    {
      xfer += oprot->writeI64(_iter131->first);
      xfer += _iter131->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("partition_columns", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_columns.size()));
    std::vector<TColumn> ::const_iterator _iter132;
    for (_iter132 = this->partition_columns.begin(); _iter132 != this->partition_columns.end(); ++_iter132)
    {
      xfer += (*_iter132).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPGTable &a, TPGTable &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
  swap(a.owner, b.owner);
  swap(a.partitions, b.partitions);
  swap(a.partition_columns, b.partition_columns);
  swap(a.sql, b.sql);
}

const char* TDsqlUri::ascii_fingerprint = "078407A192271140B6E96CEE7F2BF932";
const uint8_t TDsqlUri::binary_fingerprint[16] = {0x07,0x84,0x07,0xA1,0x92,0x27,0x11,0x40,0xB6,0xE9,0x6C,0xEE,0x7F,0x2B,0xF9,0x32};

uint32_t TDsqlUri::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast133;
          xfer += iprot->readI32(ecast133);
          this->type = (TUriType::type)ecast133;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pg_locations.clear();
            uint32_t _size134;
            ::apache::thrift::protocol::TType _etype137;
            xfer += iprot->readListBegin(_etype137, _size134);
            this->pg_locations.resize(_size134);
            uint32_t _i138;
            for (_i138 = 0; _i138 < _size134; ++_i138)
            {
              xfer += iprot->readString(this->pg_locations[_i138]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pg_locations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_nodes);
          this->__isset.num_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDsqlUri::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TDsqlUri");

  ++fcnt;
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pg_locations) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("pg_locations", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->pg_locations.size()));
      std::vector<std::string> ::const_iterator _iter139;
      for (_iter139 = this->pg_locations.begin(); _iter139 != this->pg_locations.end(); ++_iter139)
      {
        xfer += oprot->writeString((*_iter139));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.url) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->url);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db_name) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_nodes) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("num_nodes", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->num_nodes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDsqlUri &a, TDsqlUri &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.pg_locations, b.pg_locations);
  swap(a.port, b.port);
  swap(a.url, b.url);
  swap(a.db_name, b.db_name);
  swap(a.offset, b.offset);
  swap(a.num_nodes, b.num_nodes);
  swap(a.__isset, b.__isset);
}

const char* TPhoenixTable::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t TPhoenixTable::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t TPhoenixTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPhoenixTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPhoenixTable");

  ++fcnt;
  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPhoenixTable &a, TPhoenixTable &b) {
  using ::std::swap;
  swap(a.port, b.port);
}

const char* TStreamTable::ascii_fingerprint = "09E234EEAAB7732F568CAFA7D4AE0C23";
const uint8_t TStreamTable::binary_fingerprint[16] = {0x09,0xE2,0x34,0xEE,0xAA,0xB7,0x73,0x2F,0x56,0x8C,0xAF,0xA7,0xD4,0xAE,0x0C,0x23};

uint32_t TStreamTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_line_delim = false;
  bool isset_field_delim = false;
  bool isset_escape_char = false;
  bool isset_null_string = false;
  bool isset_uri = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->line_delim);
          isset_line_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field_delim);
          isset_field_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->escape_char);
          isset_escape_char = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->null_string);
          isset_null_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->uri.read(iprot);
          isset_uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_line_delim)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_field_delim)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_escape_char)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_null_string)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_uri)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStreamTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TStreamTable");

  ++fcnt;
  xfer += oprot->writeFieldBegin("line_delim", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->line_delim);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("field_delim", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->field_delim);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("escape_char", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->escape_char);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("null_string", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->null_string);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->uri.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStreamTable &a, TStreamTable &b) {
  using ::std::swap;
  swap(a.line_delim, b.line_delim);
  swap(a.field_delim, b.field_delim);
  swap(a.escape_char, b.escape_char);
  swap(a.null_string, b.null_string);
  swap(a.uri, b.uri);
}

const char* TTable::ascii_fingerprint = "93BD5F39259B96656070847913EB7E5F";
const uint8_t TTable::binary_fingerprint[16] = {0x93,0xBD,0x5F,0x39,0x25,0x9B,0x96,0x65,0x60,0x70,0x84,0x79,0x13,0xEB,0x7E,0x5F};

uint32_t TTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_tbl_name = false;
  bool isset_owner = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->load_status.read(iprot);
          this->__isset.load_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast140;
          xfer += iprot->readI32(ecast140);
          this->access_level = (TAccessLevel::type)ecast140;
          this->__isset.access_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size141;
            ::apache::thrift::protocol::TType _etype144;
            xfer += iprot->readListBegin(_etype144, _size141);
            this->columns.resize(_size141);
            uint32_t _i145;
            for (_i145 = 0; _i145 < _size141; ++_i145)
            {
              xfer += this->columns[_i145].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->clustering_columns.clear();
            uint32_t _size146;
            ::apache::thrift::protocol::TType _etype149;
            xfer += iprot->readListBegin(_etype149, _size146);
            this->clustering_columns.resize(_size146);
            uint32_t _i150;
            for (_i150 = 0; _i150 < _size146; ++_i150)
            {
              xfer += this->clustering_columns[_i150].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.clustering_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_stats.read(iprot);
          this->__isset.table_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast151;
          xfer += iprot->readI32(ecast151);
          this->table_type = (TTableType::type)ecast151;
          this->__isset.table_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hdfs_table.read(iprot);
          this->__isset.hdfs_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hbase_table.read(iprot);
          this->__isset.hbase_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metastore_table.read(iprot);
          this->__isset.metastore_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_source_table.read(iprot);
          this->__isset.data_source_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pg_table.read(iprot);
          this->__isset.pg_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stream_table.read(iprot);
          this->__isset.stream_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->phoenix_table.read(iprot);
          this->__isset.phoenix_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTable");

  ++fcnt;
  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.load_status) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("load_status", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->load_status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.access_level) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("access_level", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->access_level);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter152;
      for (_iter152 = this->columns.begin(); _iter152 != this->columns.end(); ++_iter152)
      {
        xfer += (*_iter152).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clustering_columns) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("clustering_columns", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->clustering_columns.size()));
      std::vector<TColumn> ::const_iterator _iter153;
      for (_iter153 = this->clustering_columns.begin(); _iter153 != this->clustering_columns.end(); ++_iter153)
      {
        xfer += (*_iter153).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_stats) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("table_stats", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->table_stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_type) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("table_type", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->table_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hdfs_table) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("hdfs_table", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->hdfs_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hbase_table) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("hbase_table", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->hbase_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.metastore_table) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("metastore_table", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->metastore_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data_source_table) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("data_source_table", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->data_source_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pg_table) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("pg_table", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->pg_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stream_table) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("stream_table", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->stream_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 16);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.phoenix_table) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("phoenix_table", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->phoenix_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTable &a, TTable &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.owner, b.owner);
  swap(a.load_status, b.load_status);
  swap(a.id, b.id);
  swap(a.access_level, b.access_level);
  swap(a.columns, b.columns);
  swap(a.clustering_columns, b.clustering_columns);
  swap(a.table_stats, b.table_stats);
  swap(a.table_type, b.table_type);
  swap(a.hdfs_table, b.hdfs_table);
  swap(a.hbase_table, b.hbase_table);
  swap(a.metastore_table, b.metastore_table);
  swap(a.data_source_table, b.data_source_table);
  swap(a.pg_table, b.pg_table);
  swap(a.stream_table, b.stream_table);
  swap(a.phoenix_table, b.phoenix_table);
  swap(a.__isset, b.__isset);
}

const char* TIndexColumnElement::ascii_fingerprint = "4DC2E1C714CE2A88219E171951BC21F6";
const uint8_t TIndexColumnElement::binary_fingerprint[16] = {0x4D,0xC2,0xE1,0xC7,0x14,0xCE,0x2A,0x88,0x21,0x9E,0x17,0x19,0x51,0xBC,0x21,0xF6};

uint32_t TIndexColumnElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_is_asc = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_asc);
          isset_is_asc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->null_first);
          this->__isset.null_first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_asc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIndexColumnElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TIndexColumnElement");

  ++fcnt;
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_asc", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_asc);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.null_first) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("null_first", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->null_first);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIndexColumnElement &a, TIndexColumnElement &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.is_asc, b.is_asc);
  swap(a.null_first, b.null_first);
  swap(a.__isset, b.__isset);
}

const char* TIndex::ascii_fingerprint = "67F48EB40E1A86525410A0A98BC08CE9";
const uint8_t TIndex::binary_fingerprint[16] = {0x67,0xF4,0x8E,0xB4,0x0E,0x1A,0x86,0x52,0x54,0x10,0xA0,0xA9,0x8B,0xC0,0x8C,0xE9};

uint32_t TIndex::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_tbl_name = false;
  bool isset_idx_name = false;
  bool isset_type = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->idx_name);
          isset_idx_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->columns.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              xfer += this->columns[_i158].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_idx_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIndex::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TIndex");

  ++fcnt;
  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("idx_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->idx_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TIndexColumnElement> ::const_iterator _iter159;
    for (_iter159 = this->columns.begin(); _iter159 != this->columns.end(); ++_iter159)
    {
      xfer += (*_iter159).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIndex &a, TIndex &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.idx_name, b.idx_name);
  swap(a.type, b.type);
  swap(a.columns, b.columns);
}

const char* TDatabase::ascii_fingerprint = "B879D38C24452CACBA199E11B967EAB2";
const uint8_t TDatabase::binary_fingerprint[16] = {0xB8,0x79,0xD3,0x8C,0x24,0x45,0x2C,0xAC,0xBA,0x19,0x9E,0x11,0xB9,0x67,0xEA,0xB2};

uint32_t TDatabase::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metastore_db.read(iprot);
          this->__isset.metastore_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->uri.read(iprot);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDatabase::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TDatabase");

  ++fcnt;
  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.metastore_db) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("metastore_db", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->metastore_db.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uri) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->uri.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatabase &a, TDatabase &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.metastore_db, b.metastore_db);
  swap(a.uri, b.uri);
  swap(a.__isset, b.__isset);
}

const char* TRole::ascii_fingerprint = "6AB241362403A4E30F9D3B91873CCEF0";
const uint8_t TRole::binary_fingerprint[16] = {0x6A,0xB2,0x41,0x36,0x24,0x03,0xA4,0xE3,0x0F,0x9D,0x3B,0x91,0x87,0x3C,0xCE,0xF0};

uint32_t TRole::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_role_name = false;
  bool isset_role_id = false;
  bool isset_grant_groups = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->role_name);
          isset_role_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->role_id);
          isset_role_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->grant_groups.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readListBegin(_etype163, _size160);
            this->grant_groups.resize(_size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              xfer += iprot->readString(this->grant_groups[_i164]);
            }
            xfer += iprot->readListEnd();
          }
          isset_grant_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_role_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_role_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_grant_groups)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRole::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TRole");

  ++fcnt;
  xfer += oprot->writeFieldBegin("role_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->role_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("role_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->role_id);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("grant_groups", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->grant_groups.size()));
    std::vector<std::string> ::const_iterator _iter165;
    for (_iter165 = this->grant_groups.begin(); _iter165 != this->grant_groups.end(); ++_iter165)
    {
      xfer += oprot->writeString((*_iter165));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRole &a, TRole &b) {
  using ::std::swap;
  swap(a.role_name, b.role_name);
  swap(a.role_id, b.role_id);
  swap(a.grant_groups, b.grant_groups);
}

const char* TPrivilege::ascii_fingerprint = "CC14D3F72B1FF1AA701B65CD923EA5FF";
const uint8_t TPrivilege::binary_fingerprint[16] = {0xCC,0x14,0xD3,0xF7,0x2B,0x1F,0xF1,0xAA,0x70,0x1B,0x65,0xCD,0x92,0x3E,0xA5,0xFF};

uint32_t TPrivilege::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_privilege_name = false;
  bool isset_privilege_level = false;
  bool isset_scope = false;
  bool isset_has_grant_opt = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->privilege_name);
          isset_privilege_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast166;
          xfer += iprot->readI32(ecast166);
          this->privilege_level = (TPrivilegeLevel::type)ecast166;
          isset_privilege_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast167;
          xfer += iprot->readI32(ecast167);
          this->scope = (TPrivilegeScope::type)ecast167;
          isset_scope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_grant_opt);
          isset_has_grant_opt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->role_id);
          this->__isset.role_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          this->__isset.server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->create_time_ms);
          this->__isset.create_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_privilege_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_privilege_level)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_scope)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_grant_opt)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPrivilege::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPrivilege");

  ++fcnt;
  xfer += oprot->writeFieldBegin("privilege_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->privilege_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("privilege_level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->privilege_level);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->scope);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("has_grant_opt", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->has_grant_opt);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.role_id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("role_id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->role_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.server_name) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->server_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db_name) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_name) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->table_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uri) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->uri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_time_ms) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("create_time_ms", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->create_time_ms);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_name) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->column_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPrivilege &a, TPrivilege &b) {
  using ::std::swap;
  swap(a.privilege_name, b.privilege_name);
  swap(a.privilege_level, b.privilege_level);
  swap(a.scope, b.scope);
  swap(a.has_grant_opt, b.has_grant_opt);
  swap(a.role_id, b.role_id);
  swap(a.server_name, b.server_name);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.uri, b.uri);
  swap(a.create_time_ms, b.create_time_ms);
  swap(a.column_name, b.column_name);
  swap(a.__isset, b.__isset);
}

const char* THdfsCachePool::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t THdfsCachePool::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t THdfsCachePool::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pool_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pool_name);
          isset_pool_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pool_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THdfsCachePool::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THdfsCachePool");

  ++fcnt;
  xfer += oprot->writeFieldBegin("pool_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pool_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THdfsCachePool &a, THdfsCachePool &b) {
  using ::std::swap;
  swap(a.pool_name, b.pool_name);
}

const char* TCatalog::ascii_fingerprint = "9CFE4A6581B5B8EB11F5BBBCEFA07940";
const uint8_t TCatalog::binary_fingerprint[16] = {0x9C,0xFE,0x4A,0x65,0x81,0xB5,0xB8,0xEB,0x11,0xF5,0xBB,0xBC,0xEF,0xA0,0x79,0x40};

uint32_t TCatalog::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catalog_service_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog_service_id.read(iprot);
          isset_catalog_service_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catalog_service_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCatalog::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TCatalog");

  ++fcnt;
  xfer += oprot->writeFieldBegin("catalog_service_id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->catalog_service_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCatalog &a, TCatalog &b) {
  using ::std::swap;
  swap(a.catalog_service_id, b.catalog_service_id);
}

const char* TCatalogObject::ascii_fingerprint = "A109746A41FAE72D9046FFE189A58463";
const uint8_t TCatalogObject::binary_fingerprint[16] = {0xA1,0x09,0x74,0x6A,0x41,0xFA,0xE7,0x2D,0x90,0x46,0xFF,0xE1,0x89,0xA5,0x84,0x63};

uint32_t TCatalogObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_catalog_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast168;
          xfer += iprot->readI32(ecast168);
          this->type = (TCatalogObjectType::type)ecast168;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->catalog_version);
          isset_catalog_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog.read(iprot);
          this->__isset.catalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->db.read(iprot);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fn.read(iprot);
          this->__isset.fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_source.read(iprot);
          this->__isset.data_source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->role.read(iprot);
          this->__isset.role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privilege.read(iprot);
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cache_pool.read(iprot);
          this->__isset.cache_pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->index.read(iprot);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalog_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCatalogObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TCatalogObject");

  ++fcnt;
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("catalog_version", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->catalog_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalog) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("catalog", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->catalog.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->db.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fn) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("fn", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data_source) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("data_source", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->data_source.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.role) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("role", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->role.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.privilege) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->privilege.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_pool) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("cache_pool", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->cache_pool.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->index.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCatalogObject &a, TCatalogObject &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.catalog_version, b.catalog_version);
  swap(a.catalog, b.catalog);
  swap(a.db, b.db);
  swap(a.table, b.table);
  swap(a.fn, b.fn);
  swap(a.data_source, b.data_source);
  swap(a.role, b.role);
  swap(a.privilege, b.privilege);
  swap(a.cache_pool, b.cache_pool);
  swap(a.index, b.index);
  swap(a.__isset, b.__isset);
}

} // namespace
