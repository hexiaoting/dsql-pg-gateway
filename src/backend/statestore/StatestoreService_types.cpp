/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "StatestoreService_types.h"

#include <algorithm>

namespace impala {

int _kStatestoreServiceVersionValues[] = {
  StatestoreServiceVersion::V1
};
const char* _kStatestoreServiceVersionNames[] = {
  "V1"
};
const std::map<int, const char*> _StatestoreServiceVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kStatestoreServiceVersionValues, _kStatestoreServiceVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TPoolStats::ascii_fingerprint = "66C8E6F97F0275919D86FEB536251B17";
const uint8_t TPoolStats::binary_fingerprint[16] = {0x66,0xC8,0xE6,0xF9,0x7F,0x02,0x75,0x91,0x9D,0x86,0xFE,0xB5,0x36,0x25,0x1B,0x17};

uint32_t TPoolStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_running = false;
  bool isset_num_queued = false;
  bool isset_mem_usage = false;
  bool isset_mem_estimate = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_running);
          isset_num_running = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_queued);
          isset_num_queued = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mem_usage);
          isset_mem_usage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mem_estimate);
          isset_mem_estimate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_running)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_queued)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mem_usage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mem_estimate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPoolStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPoolStats");

  ++fcnt;
  xfer += oprot->writeFieldBegin("num_running", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->num_running);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("num_queued", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->num_queued);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("mem_usage", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->mem_usage);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("mem_estimate", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->mem_estimate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPoolStats &a, TPoolStats &b) {
  using ::std::swap;
  swap(a.num_running, b.num_running);
  swap(a.num_queued, b.num_queued);
  swap(a.mem_usage, b.mem_usage);
  swap(a.mem_estimate, b.mem_estimate);
}

const char* TBackendDescriptor::ascii_fingerprint = "EA990A0C512F7B2D90DF4141EAC57F24";
const uint8_t TBackendDescriptor::binary_fingerprint[16] = {0xEA,0x99,0x0A,0x0C,0x51,0x2F,0x7B,0x2D,0x90,0xDF,0x41,0x41,0xEA,0xC5,0x7F,0x24};

uint32_t TBackendDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_address = false;
  bool isset_ip_address = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->address.read(iprot);
          isset_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip_address);
          isset_ip_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->debug_http_address.read(iprot);
          this->__isset.debug_http_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->secure_webserver);
          this->__isset.secure_webserver = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_address)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ip_address)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBackendDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TBackendDescriptor");

  ++fcnt;
  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->address.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("ip_address", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->ip_address);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.debug_http_address) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("debug_http_address", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->debug_http_address.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secure_webserver) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("secure_webserver", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->secure_webserver);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBackendDescriptor &a, TBackendDescriptor &b) {
  using ::std::swap;
  swap(a.address, b.address);
  swap(a.ip_address, b.ip_address);
  swap(a.debug_http_address, b.debug_http_address);
  swap(a.secure_webserver, b.secure_webserver);
  swap(a.__isset, b.__isset);
}

const char* TCatalogDescriptor::ascii_fingerprint = "E284A96D78462CB63C99DEFFFCBF42D0";
const uint8_t TCatalogDescriptor::binary_fingerprint[16] = {0xE2,0x84,0xA9,0x6D,0x78,0x46,0x2C,0xB6,0x3C,0x99,0xDE,0xFF,0xFC,0xBF,0x42,0xD0};

uint32_t TCatalogDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_address = false;
  bool isset_is_master = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->address.read(iprot);
          isset_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_master);
          isset_is_master = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_address)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_master)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCatalogDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TCatalogDescriptor");

  ++fcnt;
  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->address.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_master", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_master);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCatalogDescriptor &a, TCatalogDescriptor &b) {
  using ::std::swap;
  swap(a.address, b.address);
  swap(a.is_master, b.is_master);
}

const char* TTopicItem::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t TTopicItem::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t TTopicItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTopicItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTopicItem");

  ++fcnt;
  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTopicItem &a, TTopicItem &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
}

const char* TTopicDelta::ascii_fingerprint = "8B024CE7417C0CAA8AC30C26B17A11FC";
const uint8_t TTopicDelta::binary_fingerprint[16] = {0x8B,0x02,0x4C,0xE7,0x41,0x7C,0x0C,0xAA,0x8A,0xC3,0x0C,0x26,0xB1,0x7A,0x11,0xFC};

uint32_t TTopicDelta::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topic_name = false;
  bool isset_topic_entries = false;
  bool isset_topic_deletions = false;
  bool isset_is_delta = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic_name);
          isset_topic_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->topic_entries.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->topic_entries.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->topic_entries[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_topic_entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->topic_deletions.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->topic_deletions.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readString(this->topic_deletions[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          isset_topic_deletions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_delta);
          isset_is_delta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->from_version);
          this->__isset.from_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->to_version);
          this->__isset.to_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min_subscriber_topic_version);
          this->__isset.min_subscriber_topic_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topic_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_topic_entries)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_topic_deletions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_delta)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTopicDelta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTopicDelta");

  ++fcnt;
  xfer += oprot->writeFieldBegin("topic_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->topic_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("topic_entries", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->topic_entries.size()));
    std::vector<TTopicItem> ::const_iterator _iter10;
    for (_iter10 = this->topic_entries.begin(); _iter10 != this->topic_entries.end(); ++_iter10)
    {
      xfer += (*_iter10).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("topic_deletions", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->topic_deletions.size()));
    std::vector<std::string> ::const_iterator _iter11;
    for (_iter11 = this->topic_deletions.begin(); _iter11 != this->topic_deletions.end(); ++_iter11)
    {
      xfer += oprot->writeString((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_delta", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_delta);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.from_version) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("from_version", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->from_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.to_version) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("to_version", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->to_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_subscriber_topic_version) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("min_subscriber_topic_version", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->min_subscriber_topic_version);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTopicDelta &a, TTopicDelta &b) {
  using ::std::swap;
  swap(a.topic_name, b.topic_name);
  swap(a.topic_entries, b.topic_entries);
  swap(a.topic_deletions, b.topic_deletions);
  swap(a.is_delta, b.is_delta);
  swap(a.from_version, b.from_version);
  swap(a.to_version, b.to_version);
  swap(a.min_subscriber_topic_version, b.min_subscriber_topic_version);
  swap(a.__isset, b.__isset);
}

const char* TTopicRegistration::ascii_fingerprint = "7D61C9AA00102AB4D8F72A1DA58297DC";
const uint8_t TTopicRegistration::binary_fingerprint[16] = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

uint32_t TTopicRegistration::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topic_name = false;
  bool isset_is_transient = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic_name);
          isset_topic_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_transient);
          isset_is_transient = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topic_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_transient)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTopicRegistration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTopicRegistration");

  ++fcnt;
  xfer += oprot->writeFieldBegin("topic_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->topic_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_transient", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_transient);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTopicRegistration &a, TTopicRegistration &b) {
  using ::std::swap;
  swap(a.topic_name, b.topic_name);
  swap(a.is_transient, b.is_transient);
}

const char* TRegisterSubscriberRequest::ascii_fingerprint = "79FBAF663F4F9AC94F2386BD4840E86A";
const uint8_t TRegisterSubscriberRequest::binary_fingerprint[16] = {0x79,0xFB,0xAF,0x66,0x3F,0x4F,0x9A,0xC9,0x4F,0x23,0x86,0xBD,0x48,0x40,0xE8,0x6A};

uint32_t TRegisterSubscriberRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_subscriber_id = false;
  bool isset_subscriber_location = false;
  bool isset_topic_registrations = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->protocol_version = (StatestoreServiceVersion::type)ecast12;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subscriber_id);
          isset_subscriber_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->subscriber_location.read(iprot);
          isset_subscriber_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->topic_registrations.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->topic_registrations.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += this->topic_registrations[_i17].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_topic_registrations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_subscriber_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_subscriber_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_topic_registrations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRegisterSubscriberRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TRegisterSubscriberRequest");

  ++fcnt;
  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("subscriber_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->subscriber_id);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("subscriber_location", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->subscriber_location.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("topic_registrations", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->topic_registrations.size()));
    std::vector<TTopicRegistration> ::const_iterator _iter18;
    for (_iter18 = this->topic_registrations.begin(); _iter18 != this->topic_registrations.end(); ++_iter18)
    {
      xfer += (*_iter18).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRegisterSubscriberRequest &a, TRegisterSubscriberRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.subscriber_id, b.subscriber_id);
  swap(a.subscriber_location, b.subscriber_location);
  swap(a.topic_registrations, b.topic_registrations);
}

const char* TRegisterSubscriberResponse::ascii_fingerprint = "95ABC78C783842477A1610D711268739";
const uint8_t TRegisterSubscriberResponse::binary_fingerprint[16] = {0x95,0xAB,0xC7,0x8C,0x78,0x38,0x42,0x47,0x7A,0x16,0x10,0xD7,0x11,0x26,0x87,0x39};

uint32_t TRegisterSubscriberResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->registration_id.read(iprot);
          this->__isset.registration_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRegisterSubscriberResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TRegisterSubscriberResponse");

  ++fcnt;
  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.registration_id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("registration_id", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->registration_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRegisterSubscriberResponse &a, TRegisterSubscriberResponse &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.registration_id, b.registration_id);
  swap(a.__isset, b.__isset);
}

const char* TUpdateStateRequest::ascii_fingerprint = "A59C926C9D9ECF6426124D50386B433B";
const uint8_t TUpdateStateRequest::binary_fingerprint[16] = {0xA5,0x9C,0x92,0x6C,0x9D,0x9E,0xCF,0x64,0x26,0x12,0x4D,0x50,0x38,0x6B,0x43,0x3B};

uint32_t TUpdateStateRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_topic_deltas = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->protocol_version = (StatestoreServiceVersion::type)ecast19;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->topic_deltas.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _ktype21;
            ::apache::thrift::protocol::TType _vtype22;
            xfer += iprot->readMapBegin(_ktype21, _vtype22, _size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              std::string _key25;
              xfer += iprot->readString(_key25);
              TTopicDelta& _val26 = this->topic_deltas[_key25];
              xfer += _val26.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_topic_deltas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->registration_id.read(iprot);
          this->__isset.registration_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_topic_deltas)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUpdateStateRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TUpdateStateRequest");

  ++fcnt;
  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("topic_deltas", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->topic_deltas.size()));
    std::map<std::string, TTopicDelta> ::const_iterator _iter27;
    for (_iter27 = this->topic_deltas.begin(); _iter27 != this->topic_deltas.end(); ++_iter27)
    {
      xfer += oprot->writeString(_iter27->first);
      xfer += _iter27->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.registration_id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("registration_id", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->registration_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUpdateStateRequest &a, TUpdateStateRequest &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.topic_deltas, b.topic_deltas);
  swap(a.registration_id, b.registration_id);
  swap(a.__isset, b.__isset);
}

const char* TUpdateStateResponse::ascii_fingerprint = "D43731EB2BC39FDD742A01EAC89A6DC8";
const uint8_t TUpdateStateResponse::binary_fingerprint[16] = {0xD4,0x37,0x31,0xEB,0x2B,0xC3,0x9F,0xDD,0x74,0x2A,0x01,0xEA,0xC8,0x9A,0x6D,0xC8};

uint32_t TUpdateStateResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_topic_updates = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->topic_updates.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->topic_updates.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += this->topic_updates[_i32].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_topic_updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->skipped);
          this->__isset.skipped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_topic_updates)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUpdateStateResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TUpdateStateResponse");

  ++fcnt;
  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("topic_updates", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->topic_updates.size()));
    std::vector<TTopicDelta> ::const_iterator _iter33;
    for (_iter33 = this->topic_updates.begin(); _iter33 != this->topic_updates.end(); ++_iter33)
    {
      xfer += (*_iter33).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.skipped) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("skipped", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->skipped);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUpdateStateResponse &a, TUpdateStateResponse &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.topic_updates, b.topic_updates);
  swap(a.skipped, b.skipped);
  swap(a.__isset, b.__isset);
}

const char* THeartbeatRequest::ascii_fingerprint = "83CF95E7F6BE901BBAB54DE322F32AE8";
const uint8_t THeartbeatRequest::binary_fingerprint[16] = {0x83,0xCF,0x95,0xE7,0xF6,0xBE,0x90,0x1B,0xBA,0xB5,0x4D,0xE3,0x22,0xF3,0x2A,0xE8};

uint32_t THeartbeatRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->registration_id.read(iprot);
          this->__isset.registration_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t THeartbeatRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THeartbeatRequest");

  if (this->__isset.registration_id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("registration_id", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->registration_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THeartbeatRequest &a, THeartbeatRequest &b) {
  using ::std::swap;
  swap(a.registration_id, b.registration_id);
  swap(a.__isset, b.__isset);
}

const char* THeartbeatResponse::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t THeartbeatResponse::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t THeartbeatResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t THeartbeatResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THeartbeatResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THeartbeatResponse &a, THeartbeatResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

} // namespace
