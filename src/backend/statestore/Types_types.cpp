/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Types_types.h"

#include <algorithm>

namespace impala {

int _kTPrimitiveTypeValues[] = {
  TPrimitiveType::INVALID_TYPE,
  TPrimitiveType::NULL_TYPE,
  TPrimitiveType::BOOLEAN,
  TPrimitiveType::TINYINT,
  TPrimitiveType::SMALLINT,
  TPrimitiveType::INT,
  TPrimitiveType::BIGINT,
  TPrimitiveType::FLOAT,
  TPrimitiveType::DOUBLE,
  TPrimitiveType::DATE,
  TPrimitiveType::DATETIME,
  TPrimitiveType::TIMESTAMP,
  TPrimitiveType::STRING,
  TPrimitiveType::BINARY,
  TPrimitiveType::DECIMAL,
  TPrimitiveType::CHAR,
  TPrimitiveType::VARCHAR
};
const char* _kTPrimitiveTypeNames[] = {
  "INVALID_TYPE",
  "NULL_TYPE",
  "BOOLEAN",
  "TINYINT",
  "SMALLINT",
  "INT",
  "BIGINT",
  "FLOAT",
  "DOUBLE",
  "DATE",
  "DATETIME",
  "TIMESTAMP",
  "STRING",
  "BINARY",
  "DECIMAL",
  "CHAR",
  "VARCHAR"
};
const std::map<int, const char*> _TPrimitiveType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(17, _kTPrimitiveTypeValues, _kTPrimitiveTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTTypeNodeTypeValues[] = {
  TTypeNodeType::SCALAR,
  TTypeNodeType::ARRAY,
  TTypeNodeType::MAP,
  TTypeNodeType::STRUCT
};
const char* _kTTypeNodeTypeNames[] = {
  "SCALAR",
  "ARRAY",
  "MAP",
  "STRUCT"
};
const std::map<int, const char*> _TTypeNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTTypeNodeTypeValues, _kTTypeNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTStmtTypeValues[] = {
  TStmtType::QUERY,
  TStmtType::DDL,
  TStmtType::DML,
  TStmtType::EXPLAIN,
  TStmtType::LOAD,
  TStmtType::SET,
  TStmtType::DELETE,
  TStmtType::UPDATE
};
const char* _kTStmtTypeNames[] = {
  "QUERY",
  "DDL",
  "DML",
  "EXPLAIN",
  "LOAD",
  "SET",
  "DELETE",
  "UPDATE"
};
const std::map<int, const char*> _TStmtType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kTStmtTypeValues, _kTStmtTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTExplainLevelValues[] = {
  TExplainLevel::MINIMAL,
  TExplainLevel::STANDARD,
  TExplainLevel::EXTENDED,
  TExplainLevel::VERBOSE
};
const char* _kTExplainLevelNames[] = {
  "MINIMAL",
  "STANDARD",
  "EXTENDED",
  "VERBOSE"
};
const std::map<int, const char*> _TExplainLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTExplainLevelValues, _kTExplainLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFunctionCategoryValues[] = {
  TFunctionCategory::SCALAR,
  TFunctionCategory::AGGREGATE,
  TFunctionCategory::ANALYTIC
};
const char* _kTFunctionCategoryNames[] = {
  "SCALAR",
  "AGGREGATE",
  "ANALYTIC"
};
const std::map<int, const char*> _TFunctionCategory_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTFunctionCategoryValues, _kTFunctionCategoryNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFunctionBinaryTypeValues[] = {
  TFunctionBinaryType::BUILTIN,
  TFunctionBinaryType::HIVE,
  TFunctionBinaryType::NATIVE,
  TFunctionBinaryType::IR
};
const char* _kTFunctionBinaryTypeNames[] = {
  "BUILTIN",
  "HIVE",
  "NATIVE",
  "IR"
};
const std::map<int, const char*> _TFunctionBinaryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTFunctionBinaryTypeValues, _kTFunctionBinaryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TScalarType::ascii_fingerprint = "D68013E9233A1A7D7062FA286B362896";
const uint8_t TScalarType::binary_fingerprint[16] = {0xD6,0x80,0x13,0xE9,0x23,0x3A,0x1A,0x7D,0x70,0x62,0xFA,0x28,0x6B,0x36,0x28,0x96};

uint32_t TScalarType::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (TPrimitiveType::type)ecast0;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->precision);
          this->__isset.precision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scale);
          this->__isset.scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TScalarType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TScalarType");

  ++fcnt;
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.len) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->len);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.precision) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("precision", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->precision);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scale) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->scale);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScalarType &a, TScalarType &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.len, b.len);
  swap(a.precision, b.precision);
  swap(a.scale, b.scale);
  swap(a.__isset, b.__isset);
}

const char* TStructField::ascii_fingerprint = "5B708A954C550ECA9C1A49D3C5CAFAB9";
const uint8_t TStructField::binary_fingerprint[16] = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

uint32_t TStructField::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStructField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TStructField");

  ++fcnt;
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStructField &a, TStructField &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

const char* TTypeNode::ascii_fingerprint = "20F2BEB5930B41BB06CA311D86936C3E";
const uint8_t TTypeNode::binary_fingerprint[16] = {0x20,0xF2,0xBE,0xB5,0x93,0x0B,0x41,0xBB,0x06,0xCA,0x31,0x1D,0x86,0x93,0x6C,0x3E};

uint32_t TTypeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->type = (TTypeNodeType::type)ecast1;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scalar_type.read(iprot);
          this->__isset.scalar_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->struct_fields.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->struct_fields.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->struct_fields[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.struct_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTypeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTypeNode");

  ++fcnt;
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.scalar_type) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("scalar_type", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->scalar_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.struct_fields) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("struct_fields", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->struct_fields.size()));
      std::vector<TStructField> ::const_iterator _iter7;
      for (_iter7 = this->struct_fields.begin(); _iter7 != this->struct_fields.end(); ++_iter7)
      {
        xfer += (*_iter7).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeNode &a, TTypeNode &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.scalar_type, b.scalar_type);
  swap(a.struct_fields, b.struct_fields);
  swap(a.__isset, b.__isset);
}

const char* TColumnType::ascii_fingerprint = "AB152F6E2A595878B5FAFACB5FDAC6F0";
const uint8_t TColumnType::binary_fingerprint[16] = {0xAB,0x15,0x2F,0x6E,0x2A,0x59,0x58,0x78,0xB5,0xFA,0xFA,0xCB,0x5F,0xDA,0xC6,0xF0};

uint32_t TColumnType::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->types.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->types[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TColumnType");

  ++fcnt;
  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->types.size()));
    std::vector<TTypeNode> ::const_iterator _iter13;
    for (_iter13 = this->types.begin(); _iter13 != this->types.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnType &a, TColumnType &b) {
  using ::std::swap;
  swap(a.types, b.types);
  swap(a.__isset, b.__isset);
}

const char* TNetworkAddress::ascii_fingerprint = "EEBC915CE44901401D881E6091423036";
const uint8_t TNetworkAddress::binary_fingerprint[16] = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

uint32_t TNetworkAddress::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hostname = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TNetworkAddress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TNetworkAddress");

  ++fcnt;
  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNetworkAddress &a, TNetworkAddress &b) {
  using ::std::swap;
  swap(a.hostname, b.hostname);
  swap(a.port, b.port);
}

const char* TUniqueId::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t TUniqueId::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t TUniqueId::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hi = false;
  bool isset_lo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hi);
          isset_hi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lo);
          isset_lo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hi)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUniqueId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TUniqueId");

  ++fcnt;
  xfer += oprot->writeFieldBegin("hi", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->hi);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("lo", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->lo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUniqueId &a, TUniqueId &b) {
  using ::std::swap;
  swap(a.hi, b.hi);
  swap(a.lo, b.lo);
}

const char* TFunctionName::ascii_fingerprint = "383E55F0D02199A3E52B9227E13A83A2";
const uint8_t TFunctionName::binary_fingerprint[16] = {0x38,0x3E,0x55,0xF0,0xD0,0x21,0x99,0xA3,0xE5,0x2B,0x92,0x27,0xE1,0x3A,0x83,0xA2};

uint32_t TFunctionName::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_function_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->function_name);
          isset_function_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_function_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFunctionName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TFunctionName");

  if (this->__isset.db_name) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("function_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->function_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFunctionName &a, TFunctionName &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.function_name, b.function_name);
  swap(a.__isset, b.__isset);
}

const char* TScalarFunction::ascii_fingerprint = "4BF81DD46A7371532E49811022D58D36";
const uint8_t TScalarFunction::binary_fingerprint[16] = {0x4B,0xF8,0x1D,0xD4,0x6A,0x73,0x71,0x53,0x2E,0x49,0x81,0x10,0x22,0xD5,0x8D,0x36};

uint32_t TScalarFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_symbol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->symbol);
          isset_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prepare_fn_symbol);
          this->__isset.prepare_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->close_fn_symbol);
          this->__isset.close_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_symbol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TScalarFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TScalarFunction");

  ++fcnt;
  xfer += oprot->writeFieldBegin("symbol", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->symbol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.prepare_fn_symbol) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("prepare_fn_symbol", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->prepare_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.close_fn_symbol) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("close_fn_symbol", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->close_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScalarFunction &a, TScalarFunction &b) {
  using ::std::swap;
  swap(a.symbol, b.symbol);
  swap(a.prepare_fn_symbol, b.prepare_fn_symbol);
  swap(a.close_fn_symbol, b.close_fn_symbol);
  swap(a.__isset, b.__isset);
}

const char* TAggregateFunction::ascii_fingerprint = "C19FE77DB28956A990E9DB268C62B104";
const uint8_t TAggregateFunction::binary_fingerprint[16] = {0xC1,0x9F,0xE7,0x7D,0xB2,0x89,0x56,0xA9,0x90,0xE9,0xDB,0x26,0x8C,0x62,0xB1,0x04};

uint32_t TAggregateFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_intermediate_type = false;
  bool isset_update_fn_symbol = false;
  bool isset_init_fn_symbol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->intermediate_type.read(iprot);
          isset_intermediate_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_fn_symbol);
          isset_update_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->init_fn_symbol);
          isset_init_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serialize_fn_symbol);
          this->__isset.serialize_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->merge_fn_symbol);
          this->__isset.merge_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->finalize_fn_symbol);
          this->__isset.finalize_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->get_value_fn_symbol);
          this->__isset.get_value_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remove_fn_symbol);
          this->__isset.remove_fn_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignores_distinct);
          this->__isset.ignores_distinct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_intermediate_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_update_fn_symbol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_init_fn_symbol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAggregateFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAggregateFunction");

  ++fcnt;
  xfer += oprot->writeFieldBegin("intermediate_type", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->intermediate_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("update_fn_symbol", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->update_fn_symbol);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("init_fn_symbol", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->init_fn_symbol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.serialize_fn_symbol) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("serialize_fn_symbol", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->serialize_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.merge_fn_symbol) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("merge_fn_symbol", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->merge_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.finalize_fn_symbol) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("finalize_fn_symbol", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->finalize_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ignores_distinct) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("ignores_distinct", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->ignores_distinct);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_value_fn_symbol) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("get_value_fn_symbol", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->get_value_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remove_fn_symbol) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("remove_fn_symbol", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->remove_fn_symbol);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAggregateFunction &a, TAggregateFunction &b) {
  using ::std::swap;
  swap(a.intermediate_type, b.intermediate_type);
  swap(a.update_fn_symbol, b.update_fn_symbol);
  swap(a.init_fn_symbol, b.init_fn_symbol);
  swap(a.serialize_fn_symbol, b.serialize_fn_symbol);
  swap(a.merge_fn_symbol, b.merge_fn_symbol);
  swap(a.finalize_fn_symbol, b.finalize_fn_symbol);
  swap(a.get_value_fn_symbol, b.get_value_fn_symbol);
  swap(a.remove_fn_symbol, b.remove_fn_symbol);
  swap(a.ignores_distinct, b.ignores_distinct);
  swap(a.__isset, b.__isset);
}

const char* TFunction::ascii_fingerprint = "8730A81FA44B4BAD2A51E82F5FA9C597";
const uint8_t TFunction::binary_fingerprint[16] = {0x87,0x30,0xA8,0x1F,0xA4,0x4B,0x4B,0xAD,0x2A,0x51,0xE8,0x2F,0x5F,0xA9,0xC5,0x97};

uint32_t TFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_binary_type = false;
  bool isset_arg_types = false;
  bool isset_ret_type = false;
  bool isset_has_var_args = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->name.read(iprot);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->binary_type = (TFunctionBinaryType::type)ecast14;
          isset_binary_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arg_types.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->arg_types.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += this->arg_types[_i19].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_arg_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ret_type.read(iprot);
          isset_ret_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_var_args);
          isset_has_var_args = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfs_location);
          this->__isset.hdfs_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scalar_fn.read(iprot);
          this->__isset.scalar_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->aggregate_fn.read(iprot);
          this->__isset.aggregate_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->md5);
          this->__isset.md5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_binary_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_arg_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ret_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_var_args)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TFunction");

  ++fcnt;
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->name.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("binary_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->binary_type);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("arg_types", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arg_types.size()));
    std::vector<TColumnType> ::const_iterator _iter20;
    for (_iter20 = this->arg_types.begin(); _iter20 != this->arg_types.end(); ++_iter20)
    {
      xfer += (*_iter20).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("ret_type", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->ret_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("has_var_args", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->has_var_args);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hdfs_location) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("hdfs_location", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->hdfs_location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scalar_fn) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("scalar_fn", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->scalar_fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aggregate_fn) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("aggregate_fn", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->aggregate_fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.md5) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("md5", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->md5);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFunction &a, TFunction &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.binary_type, b.binary_type);
  swap(a.arg_types, b.arg_types);
  swap(a.ret_type, b.ret_type);
  swap(a.has_var_args, b.has_var_args);
  swap(a.comment, b.comment);
  swap(a.signature, b.signature);
  swap(a.hdfs_location, b.hdfs_location);
  swap(a.scalar_fn, b.scalar_fn);
  swap(a.aggregate_fn, b.aggregate_fn);
  swap(a.md5, b.md5);
  swap(a.__isset, b.__isset);
}

} // namespace
